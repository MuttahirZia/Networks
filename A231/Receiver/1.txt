import java.io.*;
import java.math.BigInteger;
import java.net.*;
import java.nio.ByteBuffer;
import java.util.*;
import java.nio.file.*;

public class SenderThread extends Thread {

  final int BUFFER_IN = 124; //in bytes
  final BUFFER_OUT = 124; //in bytes
  private DatagramSocket socket = null;
  private FileInputStream in = null;
  private ean moreFrames = true;
  private boolean flagEOF = false;
  private boolean flagTimeout = false;
  private int seq =   private int ack = 0;
  private byte[] bufIn = new byte[BUFFER_IN];
  private byte[] bufOut = new byte[BUFFER_OUT];
ivate DatagramPacket packet = null;
  private InetAddress address = null;
  private int in_port = 8888;
  private int_port = 9999;
  private String filename = "";
  private int timeout = 0;

//constructor, not even used
  public Senhread(String addr, int oport, int iport, String fname, int time) throws IOException {
    this("SenderThread", addr, op iport, fname, time);
  }

//constructor, all params
  public SenderThread(String name, String addr, int oport, int t, String fname, int time ) throws IOException {
    super(name);
    address = InetAddress.getByName(addr);
    in_p= iport;
    out_port = oport;
    filename = fname;
    timeout = time; // in microseconds

    socket = new Datagocket(in_port);

    try {
      Path path = Paths.get(filename);
      in = new FileInputStream(path.toFile());
  catch (FileNotFoundException e) {
      System.err.println("Could not open file. Please provide file as an absolute pat quotation marks.");
    }
  }

//main
  public void run() {
    while (moreFrames) {
      try {
        // rec request
        bufIn = new byte[BUFFER_IN]; //clear buffer
        packet = new DatagramPacket(bufIn, bufIn.length);      try{
          socket.receive(packet);
          socket.setSoTimeout(Math.round(timeout/1000));
          ack =eger.parseInt(new String(packet.getData(), 0, packet.getLength()));
          System.out.println("Recieved packet: " + ;
          System.out.println("On packet: " + seq);
        } catch (SocketTimeoutException e) {
          System.ouintln("timeout");
        }

        // send the response to the client at "address" and "port"
        getNextFrame//buf gets updated in this method

        //EOF
        if(flagEOF == true){
          bufOut = new byte[BUFFER_OUT/clear buffer
          
          byte[] seq_num = getSeqByte(seq+1);
          ByteArrayOutputStream outputStream = ByteArrayOutputStream();
          outputStream.write(seq_num);
          outputStream.write(Integer.toString(ack).gees());
          bufOut = outputStream.toByteArray();
          packet = new DatagramPacket(bufOut, bufOut.length, add, out_port);
          socket.send(packet);
          moreFrames = false;
          break;
        }

        //Seacket normally
        packet = new DatagramPacket(bufOut, bufOut.length, address, out_port);
        socket.send(pack
        System.out.println("Sent packet ending on: " + seq);

      } catch (IOException e) {
        e.printStackT();
        moreFrames = false;
      }
    }
    socket.close();
  }

  private void getNextFrame() {
    int bRead = 0;
    try {
      if (seq != ack || seq == -1){ //Need to resend
        System.out.println("RESEND");
     eturn;
      }
      System.out.println("SEQUENCE NUMBER IS: " + (seq+1));
      bufOut = new byte[BUFFER_OUT-8]; //c buffer
      bytesRead = in.read(bufOut); //Update buffer

      if (bytesRead != -1) { //Send
        System.out.pln("SEND");
        //resize buffer to match shape of data
        
        byte[] seq_num = new byte[8];
        sem = getSeqByte(seq+1);
        byte[] resizebuf = new byte[bytesRead];
        System.arraycopy(bufOut,0,resizebuf,0,bRead);
        bufOut = new byte[bytesRead];
        System.arraycopy(resizebuf,0,bufOut,0,bytesRead);

        ByteyOutputStream outputStream = new ByteArrayOutputStream();
        outputStream.write(seq_num);
        outputStream.wrbufOut);
        byte[] tempbuf = outputStream.toByteArray();
        bufOut = new byte[tempbuf.length];
        Systrraycopy(tempbuf,0,bufOut,0,tempbuf.length);

        seq += bufOut.length;
      } else { //EOF
        System.out.tln("EOF");
        in.close();
        flagEOF = true;
      }
    } catch (IOException e) {
      moreFrames = fa
    }
    return;
  }

  private byte[] getSeqByte(int seq) {
    ByteBuffer byteBuffer = ByteBuffer.allocate(8);  byteBuffer.putInt(seq);
    return byteBuffer.array();
  }
}

import java.io.*;
import java.math.BigInteger;
im java.net.*;
import java.nio.ByteBuffer;
import java.util.*;
import java.nio.file.*;

public class SenderThread ext Thread {

  final int BUFFER_IN = 124; //in bytes
  final int BUFFER_OUT = 124; //in bytes
  private DatagramSocketket = null;
  private FileInputStream in = null;
  private boolean moreFrames = true;
  private boolean flagEOF = fal
  private boolean flagTimeout = false;
  private int seq = 0;
  private int ack = 0;
  private byte[] bufIn = new byUFFER_IN];
  private byte[] bufOut = new byte[BUFFER_OUT];
  private DatagramPacket packet = null;
  private InetAddraddress = null;
  private int in_port = 8888;
  private int out_port = 9999;
  private String filename = "";
  privant timeout = 0;

//constructor, not even used
  public SenderThread(String addr, int oport, int iport, String fname, time) throws IOException {
    this("SenderThread", addr, oport, iport, fname, time);
  }

//constructor, all paramspublic SenderThread(String name, String addr, int oport, int iport, String fname, int time ) throws IOException {
    s(name);
    address = InetAddress.getByName(addr);
    in_port = iport;
    out_port = oport;
    filename = fname; timeout = time; // in microseconds

    socket = new DatagramSocket(in_port);

    try {
      Path path = Paths.gilename);
      in = new FileInputStream(path.toFile());
    } catch (FileNotFoundException e) {
      System.err.pri("Could not open file. Please provide file as an absolute path in quotation marks.");
    }
  }

//main
  public voun() {
    while (moreFrames) {
      try {
        // receive request
        bufIn = new byte[BUFFER_IN]; //clear er
        packet = new DatagramPacket(bufIn, bufIn.length);
        try{
          socket.receive(packet);
        cket.setSoTimeout(Math.round(timeout/1000));
          ack = Integer.parseInt(new String(packet.getData(), 0, packet.gegth()));
          System.out.println("Recieved packet: " + ack);
          System.out.println("On packet: " + seq);
    } catch (SocketTimeoutException e) {
          System.out.println("timeout");
        }

        // send the rese to the client at "address" and "port"
        getNextFrame(); //buf gets updated in this method

        //EOF
    if(flagEOF == true){
          bufOut = new byte[BUFFER_OUT]; //clear buffer
          
          byte[] seq_num = gqByte(seq+1);
          ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
          outputStream.write_num);
          outputStream.write(Integer.toString(ack).getBytes());
          bufOut = outputStream.toByteArray();       packet = new DatagramPacket(bufOut, bufOut.length, address, out_port);
          socket.send(packet);
         eFrames = false;
          break;
        }

        //Send packet normally
        packet = new DatagramPacket(buf bufOut.length, address, out_port);
        socket.send(packet);
        System.out.println("Sent packet ending on: " q);

      } catch (IOException e) {
        e.printStackTrace();
        moreFrames = false;
      }
    }
    st.close();
  }

  private void getNextFrame() {
    int bytesRead = 0;
    try {
      if (seq != ack || seq == -1/Need to resend
        System.out.println("RESEND");
        return;
      }
      System.out.println("SEQUENCE NUMIS: " + (seq+1));
      bufOut = new byte[BUFFER_OUT-8]; //clear buffer
      bytesRead = in.read(bufOut); //Update bu

      if (bytesRead != -1) { //Send
        System.out.println("SEND");
        //resize buffer to match shape of 
        
        byte[] seq_num = new byte[8];
        seq_num = getSeqByte(seq+1);
        byte[] resizebuf = new [bytesRead];
        System.arraycopy(bufOut,0,resizebuf,0,bytesRead);
        bufOut = new byte[bytesRead];
        em.arraycopy(resizebuf,0,bufOut,0,bytesRead);

        ByteArrayOutputStream outputStream = new ByteArrayOutputStream(        outputStream.write(seq_num);
        outputStream.write(bufOut);
        byte[] tempbuf = outputStream.toByteA();
        bufOut = new byte[tempbuf.length];
        System.arraycopy(tempbuf,0,bufOut,0,tempbuf.length);

        += bufOut.length;
      } else { //EOF
        System.out.println("EOF");
        in.close();
        flagEOF = tru      }
    } catch (IOException e) {
      moreFrames = false;
    }
    return;
  }

  private byte[] getSeqBytt seq) {
    ByteBuffer byteBuffer = ByteBuffer.allocate(8);
    byteBuffer.putInt(seq);
    return byteBuffer.array(  }
}

import java.io.*;
import java.math.BigInteger;
import java.net.*;
import java.nio.ByteBuffer;
import java..*;
import java.nio.file.*;

public class SenderThread extends Thread {

  final int BUFFER_IN = 124; //in bytes
 al int BUFFER_OUT = 124; //in bytes
  private DatagramSocket socket = null;
  private FileInputStream in = null;
  pre boolean moreFrames = true;
  private boolean flagEOF = false;
  private boolean flagTimeout = false;
  private int = 0;
  private int ack = 0;
  private byte[] bufIn = new byte[BUFFER_IN];
  private byte[] bufOut = new byte[BUFFER_O
  private DatagramPacket packet = null;
  private InetAddress address = null;
  private int in_port = 8888;
  privant out_port = 9999;
  private String filename = "";
  private int timeout = 0;

//constructor, not even used
  publenderThread(String addr, int oport, int iport, String fname, int time) throws IOException {
    this("SenderThread", adoport, iport, fname, time);
  }

//constructor, all params
  public SenderThread(String name, String addr, int oportt iport, String fname, int time ) throws IOException {
    super(name);
    address = InetAddress.getByName(addr);
  _port = iport;
    out_port = oport;
    filename = fname;
    timeout = time; // in microseconds

    socket = newagramSocket(in_port);

    try {
      Path path = Paths.get(filename);
      in = new FileInputStream(path.toFile()    } catch (FileNotFoundException e) {
      System.err.println("Could not open file. Please provide file as an absoluath in quotation marks.");
    }
  }

//main
  public void run() {
    while (moreFrames) {
      try {
        eceive request
        bufIn = new byte[BUFFER_IN]; //clear buffer
        packet = new DatagramPacket(bufIn, bufIn.le);
        try{
          socket.receive(packet);
          socket.setSoTimeout(Math.round(timeout/1000));
          = Integer.parseInt(new String(packet.getData(), 0, packet.getLength()));
          System.out.println("Recieved packet+ ack);
          System.out.println("On packet: " + seq);
        } catch (SocketTimeoutException e) {
          Sysout.println("timeout");
        }

        // send the response to the client at "address" and "port"
        getNexme(); //buf gets updated in this method

        //EOF
        if(flagEOF == true){
          bufOut = new byte[BUFFUT]; //clear buffer
          
          byte[] seq_num = getSeqByte(seq+1);
          ByteArrayOutputStream outputSt = new ByteArrayOutputStream();
          outputStream.write(seq_num);
          outputStream.write(Integer.toString(agetBytes());
          bufOut = outputStream.toByteArray();
          packet = new DatagramPacket(bufOut, bufOut.lengtddress, out_port);
          socket.send(packet);
          moreFrames = false;
          break;
        }

      Send packet normally
        packet = new DatagramPacket(bufOut, bufOut.length, address, out_port);
        socket.sencket);
        System.out.println("Sent packet ending on: " + seq);

      } catch (IOException e) {
        e.printkTrace();
        moreFrames = false;
      }
    }
    socket.close();
  }

  private void getNextFrame() {
    bytesRead = 0;
    try {
      if (seq != ack || seq == -1){ //Need to resend
        System.out.println("RESEND");     return;
      }
      System.out.println("SEQUENCE NUMBER IS: " + (seq+1));
      bufOut = new byte[BUFFER_OUT-8/clear buffer
      bytesRead = in.read(bufOut); //Update buffer

      if (bytesRead != -1) { //Send
        System.println("SEND");
        //resize buffer to match shape of data
        
        byte[] seq_num = new byte[8];
    seq_num = getSeqByte(seq+1);
        byte[] resizebuf = new byte[bytesRead];
        System.arraycopy(bufOut,0,resizeb,bytesRead);
        bufOut = new byte[bytesRead];
        System.arraycopy(resizebuf,0,bufOut,0,bytesRead);

      teArrayOutputStream outputStream = new ByteArrayOutputStream();
        outputStream.write(seq_num);
        outputStrwrite(bufOut);
        byte[] tempbuf = outputStream.toByteArray();
        bufOut = new byte[tempbuf.length];
      stem.arraycopy(tempbuf,0,bufOut,0,tempbuf.length);

        seq += bufOut.length;
      } else { //EOF
        Systet.println("EOF");
        in.close();
        flagEOF = true;
      }
    } catch (IOException e) {
      moreFramefalse;
    }
    return;
  }

  private byte[] getSeqByte(int seq) {
    ByteBuffer byteBuffer = ByteBuffer.alloca);
    byteBuffer.putInt(seq);
    return byteBuffer.array();
  }
}

import java.io.*;
import java.math.BigIntegeimport java.net.*;
import java.nio.ByteBuffer;
import java.util.*;
import java.nio.file.*;

public class SenderThrextends Thread {

  final int BUFFER_IN = 124; //in bytes
  final int BUFFER_OUT = 124; //in bytes
  private Datagramet socket = null;
  private FileInputStream in = null;
  private boolean moreFrames = true;
  private boolean flagEOFalse;
  private boolean flagTimeout = false;
  private int seq = 0;
  private int ack = 0;
  private byte[] bufIn = byte[BUFFER_IN];
  private byte[] bufOut = new byte[BUFFER_OUT];
  private DatagramPacket packet = null;
  private Indress address = null;
  private int in_port = 8888;
  private int out_port = 9999;
  private String filename = "";
 vate int timeout = 0;

//constructor, not even used
  public SenderThread(String addr, int oport, int iport, String f, int time) throws IOException {
    this("SenderThread", addr, oport, iport, fname, time);
  }

//constructor, all ms
  public SenderThread(String name, String addr, int oport, int iport, String fname, int time ) throws IOException { super(name);
    address = InetAddress.getByName(addr);
    in_port = iport;
    out_port = oport;
    filename = f;
    timeout = time; // in microseconds

    socket = new DatagramSocket(in_port);

    try {
      Path path = P.get(filename);
      in = new FileInputStream(path.toFile());
    } catch (FileNotFoundException e) {
      System.erintln("Could not open file. Please provide file as an absolute path in quotation marks.");
    }
  }

//main
  pubvoid run() {
    while (moreFrames) {
      try {
        // receive request
        bufIn = new byte[BUFFER_IN]; //r buffer
        packet = new DatagramPacket(bufIn, bufIn.length);
        try{
          socket.receive(packet);
      socket.setSoTimeout(Math.round(timeout/1000));
          ack = Integer.parseInt(new String(packet.getData(), 0, pacgetLength()));
          System.out.println("Recieved packet: " + ack);
          System.out.println("On packet: " + s
        } catch (SocketTimeoutException e) {
          System.out.println("timeout");
        }

        // send tesponse to the client at "address" and "port"
        getNextFrame(); //buf gets updated in this method

        //EO       if(flagEOF == true){
          bufOut = new byte[BUFFER_OUT]; //clear buffer
          
          byte[] seq_n getSeqByte(seq+1);
          ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
          outputStreamte(seq_num);
          outputStream.write(Integer.toString(ack).getBytes());
          bufOut = outputStream.toByteArr;
          packet = new DatagramPacket(bufOut, bufOut.length, address, out_port);
          socket.send(packet);
      moreFrames = false;
          break;
        }

        //Send packet normally
        packet = new DatagramPackufOut, bufOut.length, address, out_port);
        socket.send(packet);
        System.out.println("Sent packet ending " + seq);

      } catch (IOException e) {
        e.printStackTrace();
        moreFrames = false;
      }
    } socket.close();
  }

  private void getNextFrame() {
    int bytesRead = 0;
    try {
      if (seq != ack || seq-1){ //Need to resend
        System.out.println("RESEND");
        return;
      }
      System.out.println("SEQUENUMBER IS: " + (seq+1));
      bufOut = new byte[BUFFER_OUT-8]; //clear buffer
      bytesRead = in.read(bufOut); //Updbuffer

      if (bytesRead != -1) { //Send
        System.out.println("SEND");
        //resize buffer to match shaf data
        
        byte[] seq_num = new byte[8];
        seq_num = getSeqByte(seq+1);
        byte[] resizebuf w byte[bytesRead];
        System.arraycopy(bufOut,0,resizebuf,0,bytesRead);
        bufOut = new byte[bytesRead];
    System.arraycopy(resizebuf,0,bufOut,0,bytesRead);

        ByteArrayOutputStream outputStream = new ByteArrayOutputSm();
        outputStream.write(seq_num);
        outputStream.write(bufOut);
        byte[] tempbuf = outputStream.teArray();
        bufOut = new byte[tempbuf.length];
        System.arraycopy(tempbuf,0,bufOut,0,tempbuf.length);

    seq += bufOut.length;
      } else { //EOF
        System.out.println("EOF");
        in.close();
        flagEOFrue;
      }
    } catch (IOException e) {
      moreFrames = false;
    }
    return;
  }

  private byte[] getyte(int seq) {
    ByteBuffer byteBuffer = ByteBuffer.allocate(8);
    byteBuffer.putInt(seq);
    return byteBuffer.y();
  }
}

import java.io.*;
import java.math.BigInteger;
import java.net.*;
import java.nio.ByteBuffer;
importa.util.*;
import java.nio.file.*;

public class SenderThread extends Thread {

  final int BUFFER_IN = 124; //in by
  final int BUFFER_OUT = 124; //in bytes
  private DatagramSocket socket = null;
  private FileInputStream in = null;private boolean moreFrames = true;
  private boolean flagEOF = false;
  private boolean flagTimeout = false;
  privatt seq = 0;
  private int ack = 0;
  private byte[] bufIn = new byte[BUFFER_IN];
  private byte[] bufOut = new byte[BU_OUT];
  private DatagramPacket packet = null;
  private InetAddress address = null;
  private int in_port = 8888;
 vate int out_port = 9999;
  private String filename = "";
  private int timeout = 0;

//constructor, not even used
blic SenderThread(String addr, int oport, int iport, String fname, int time) throws IOException {
    this("SenderThreaaddr, oport, iport, fname, time);
  }

//constructor, all params
  public SenderThread(String name, String addr, intrt, int iport, String fname, int time ) throws IOException {
    super(name);
    address = InetAddress.getByName(addr    in_port = iport;
    out_port = oport;
    filename = fname;
    timeout = time; // in microseconds

    socketew DatagramSocket(in_port);

    try {
      Path path = Paths.get(filename);
      in = new FileInputStream(path.to());
    } catch (FileNotFoundException e) {
      System.err.println("Could not open file. Please provide file as an lute path in quotation marks.");
    }
  }

//main
  public void run() {
    while (moreFrames) {
      try {
    // receive request
        bufIn = new byte[BUFFER_IN]; //clear buffer
        packet = new DatagramPacket(bufIn, bulength);
        try{
          socket.receive(packet);
          socket.setSoTimeout(Math.round(timeout/1000));
      ack = Integer.parseInt(new String(packet.getData(), 0, packet.getLength()));
          System.out.println("Recieved et: " + ack);
          System.out.println("On packet: " + seq);
        } catch (SocketTimeoutException e) {
       ystem.out.println("timeout");
        }

        // send the response to the client at "address" and "port"
        extFrame(); //buf gets updated in this method

        //EOF
        if(flagEOF == true){
          bufOut = new bytFFER_OUT]; //clear buffer
          
          byte[] seq_num = getSeqByte(seq+1);
          ByteArrayOutputStream ouStream = new ByteArrayOutputStream();
          outputStream.write(seq_num);
          outputStream.write(Integer.toSt(ack).getBytes());
          bufOut = outputStream.toByteArray();
          packet = new DatagramPacket(bufOut, bufOutgth, address, out_port);
          socket.send(packet);
          moreFrames = false;
          break;
        }

    //Send packet normally
        packet = new DatagramPacket(bufOut, bufOut.length, address, out_port);
        sockend(packet);
        System.out.println("Sent packet ending on: " + seq);

      } catch (IOException e) {
        entStackTrace();
        moreFrames = false;
      }
    }
    socket.close();
  }

  private void getNextFrame()    int bytesRead = 0;
    try {
      if (seq != ack || seq == -1){ //Need to resend
        System.out.println("RESE;
        return;
      }
      System.out.println("SEQUENCE NUMBER IS: " + (seq+1));
      bufOut = new byte[BUFFER-8]; //clear buffer
      bytesRead = in.read(bufOut); //Update buffer

      if (bytesRead != -1) { //Send
        em.out.println("SEND");
        //resize buffer to match shape of data
        
        byte[] seq_num = new byte[8];      seq_num = getSeqByte(seq+1);
        byte[] resizebuf = new byte[bytesRead];
        System.arraycopy(bufOut,0,rebuf,0,bytesRead);
        bufOut = new byte[bytesRead];
        System.arraycopy(resizebuf,0,bufOut,0,bytesRead);

    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        outputStream.write(seq_num);
        outtream.write(bufOut);
        byte[] tempbuf = outputStream.toByteArray();
        bufOut = new byte[tempbuf.length];
    System.arraycopy(tempbuf,0,bufOut,0,tempbuf.length);

        seq += bufOut.length;
      } else { //EOF
       tem.out.println("EOF");
        in.close();
        flagEOF = true;
      }
    } catch (IOException e) {
      mormes = false;
    }
    return;
  }

  private byte[] getSeqByte(int seq) {
    ByteBuffer byteBuffer = ByteBuffer.cate(8);
    byteBuffer.putInt(seq);
    return byteBuffer.array();
  }
}
                                         