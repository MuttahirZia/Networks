




Network Working Group                                     T. Berners-Lee
Request for Comments: 1945                                   MIT/LCS
Category: Informational                                      R. Fielding
                                                           UC Irvine
                                                              rystyk
                                                                 MIT/LCS
                                                            May 1996


                Hypertext Transfer Protocol -- HTTP/1.0

Status of This Memo

  s memo provides information for the Internet community.  This memo
   does not specify an Internet standard of any kindistribution of
   this memo is unlimited.

IESG Note:

   The IESG has concerns about this protocol, and expects thocument
   to be replaced relatively soon by a standards track document.

Abstract

   The Hypertext Transfer Proto(HTTP) is an application-level
   protocol with the lightness and speed necessary for distributed,
   collaborative, hmedia information systems. It is a generic,
   stateless, object-oriented protocol which can be used for many tasks,
 ch as name servers and distributed object management systems,
   through extension of its request methods (commands). Ature of
   HTTP is the typing of data representation, allowing systems to be
   built independently of the data being sferred.

   HTTP has been in use by the World-Wide Web global information
   initiative since 1990. This specificatieflects common usage of
   the protocol referred to as "HTTP/1.0".

Table of Contents

   1.  Introduction ..........................................  4
       1.1  Purpose ..............................................  4
       1.2rminology ..........................................  4
       1.3  Overall Operation ................................. 6
       1.4  HTTP and MIME ........................................  8
   2.  Notational Conventions and Generic Gra ................  8
       2.1  Augmented BNF ........................................  8
       2.2  Basic Rules ...................................... 10
   3.  Protocol Parameters ....................................... 12



Ber-Lee, et al           Informational                      [Page 1]

RFC 1945                        HTTP/1.0                    May 1996


       3.1  HTTP Version ......................................... 12
       3.2  Uniform ResouIdentifiers ......................... 14
            3.2.1  General Syntax ................................ 14
        3.2.2  http URL ...................................... 15
       3.3  Date/Time Formats ................................ 15
       3.4  Character Sets ....................................... 17
       3.5  Content Codings .................................. 18
       3.6  Media Types .......................................... 19
            3.6.1  Canonization and Text Defaults ............ 19
            3.6.2  Multipart Types ............................... 20
        Product Tokens ....................................... 20
   4.  HTTP Message .......................................... 21
       4.1  Message Types ........................................ 21
       4.2  Message Headers .................................. 22
       4.3  General Header Fields ................................ 23
   5.  Request ............................................... 23
       5.1  Request-Line ......................................... 23
        5.1.1  Method ........................................ 24
            5.1.2  Request-URI ............................... 24
       5.2  Request Header Fields ................................ 25
   6.  Response .............................................. 25
       6.1  Status-Line .......................................... 26
            6.1.1  StaCode and Reason Phrase ................. 26
       6.2  Response Header Fields ............................... 28
   7ntity .................................................... 28
       7.1  Entity Header Fields ............................. 29
       7.2  Entity Body .......................................... 29
            7.2.1  Type ...................................... 29
            7.2.2  Length ........................................ 30
   8.  Method Definit ........................................ 30
       8.1  GET .................................................. 31
   8.2  HEAD ................................................. 31
       8.3  POST ............................................. 31
   9.  Status Code Definitions ................................... 32
       9.1  Informational 1xx ................................ 32
       9.2  Successful 2xx ....................................... 32
       9.3  Redirect3xx ...................................... 34
       9.4  Client Error 4xx ..................................... 35
   9.5  Server Error 5xx ..................................... 37
   10. Header Field Definitions .............................. 37
       10.1  Allow ............................................... 38
       10.2  Authorization ................................... 38
       10.3  Content-Encoding .................................... 39
       10.4  Contenngth ...................................... 39
       10.5  Content-Type ........................................ 40
   10.6  Date ................................................ 40
       10.7  Expires ......................................... 41
       10.8  From ................................................ 42



Berners-Lee, et al           Imational                      [Page 2]

RFC 1945                        HTTP/1.0                        May 1996

    10.9  If-Modified-Since ................................... 42
       10.10 Last-Modified ................................... 43
       10.11 Location ............................................ 44
       10.12 Pragma .......................................... 44
       10.13 Referer ............................................. 44
       10.14 Ser.............................................. 45
       10.15 User-Agent .......................................... 46     10.16 WWW-Authenticate .................................... 46
   11. Access Authentication ................................. 47
       11.1  Basic Authentication Scheme ......................... 48
   12. Security Considerations ............................... 49
       12.1  Authentication of Clients ........................... 49
       12.2  Saethods ........................................ 49
       12.3  Abuse of Server Log Information ..................... 5      12.4  Transfer of Sensitive Information ................... 50
       12.5  Attacks Based On File and Path Names ............ 51
   13. Acknowledgments ........................................... 51
   14. References ............................................ 52
   15. Authors' Addresses ........................................ 54
   Appendix A.nternet Media Type message/http ................ 55
   Appendix B.   Tolerant Applications ...........................    Appendix C.   Relationship to MIME ............................ 56
       C.1  Conversion to Canonical Form ..................... 56
       C.2  Conversion of Date Formats ........................... 57
       C.3  Introduction of Con-Encoding ..................... 57
       C.4  No Content-Transfer-Encoding ......................... 57
       C.5  HHeader Fields in Multipart Body-Parts ........... 57
   Appendix D.   Additional Features .............................
       D.1  Additional Request Methods ........................... 58
            D.1.1  PUT ....................................... 58
            D.1.2  DELETE ........................................ 58
            D.1.3  LINK ...................................... 58
            D.1.4  UNLINK ........................................ 58
       D.2  tional Header Field Definitions .................. 58
            D.2.1  Accept .......................................
            D.2.2  Accept-Charset ................................ 59
            D.2.3  Accept-Encoding ........................... 59
            D.2.4  Accept-Language ............................... 59
            D.2.5  Content-Lage .............................. 59
            D.2.6  Link .......................................... 59
           .7  MIME-Version .................................. 59
            D.2.8  Retry-After .................................0
            D.2.9  Title ......................................... 60
            D.2.10 URI ....................................... 60







Berners-Lee, et al           Informational                      [Page 3]

RFC 1945                    HTTP/1.0                        May 1996


1.  Introduction

1.1  Purpose

   The Hypertext Tfer Protocol (HTTP) is an application-level
   protocol with the lightness and speed necessary for distributed,
   colrative, hypermedia information systems. HTTP has been in use
   by the World-Wide Web global information initiative sin990. This
   specification reflects common usage of the protocol referred too as
   "HTTP/1.0". This specification deses the features that seem to be
   consistently implemented in most HTTP/1.0 clients and servers. The
   specificationsplit into two sections. Those features of HTTP for
   which implementations are usually consistent are described in th  main body of this document. Those features which have few or
   inconsistent implementations are listed in Appendix D
   Practical information systems require more functionality than simple
   retrieval, including search, front-end updaand annotation. HTTP
   allows an open-ended set of methods to be used to indicate the
   purpose of a request. It buion the discipline of reference
   provided by the Uniform Resource Identifier (URI) [2], as a location
   (URL) [4] ore (URN) [16], for indicating the resource on which a
   method is to be applied. Messages are passed in a format simila
   that used by Internet Mail [7] and the Multipurpose Internet Mail
   Extensions (MIME) [5].

   HTTP is also use a generic protocol for communication between
   user agents and proxies/gateways to other Internet protocols, such asSMTP [12], NNTP [11], FTP [14], Gopher [1], and WAIS [8], allowing
   basic hypermedia access to resources available friverse
   applications and simplifying the implementation of user agents.

1.2  Terminology

   This specification  a number of terms to refer to the roles
   played by participants in, and objects of, the HTTP communication.

   cotion

       A transport layer virtual circuit established between two
       application programs for the purpose ofmunication.

   message

       The basic unit of HTTP communication, consisting of a structured
       sequence ofets matching the syntax defined in Section 4 and
       transmitted via the connection.




Berners-Lee, et al       Informational                      [Page 4]

RFC 1945                        HTTP/1.0                        May 1


   request

       An HTTP request message (as defined in Section 5).

   response

       An HTTP response mge (as defined in Section 6).

   resource

       A network data object or service which can be identified by a
   URI (Section 3.2).

   entity

       A particular representation or rendition of a data resource, or
       replym a service resource, that may be enclosed within a
       request or response message. An entity consists of
       mnformation in the form of entity headers and content in the
       form of an entity body.

   client

       An apation program that establishes connections for the
       purpose of sending requests.

   user agent

       The ct which initiates a request. These are often browsers,
       editors, spiders (web-traversing robots), or other end us       tools.

   server

       An application program that accepts connections in order to
       service request sending back responses.

   origin server

       The server on which a given resource resides or is to be created.   proxy

       An intermediary program which acts as both a server and a client
       for the purpose of making rets on behalf of other clients.
       Requests are serviced internally or by passing them, with
       possible transln, on to other servers. A proxy must
       interpret and, if necessary, rewrite a request message before



Bernere, et al           Informational                      [Page 5]

RFC 1945                        HTTP/1.0                    May 1996


       forwarding it. Proxies are often used as client-side portals
       through network firewalnd as helper applications for
       handling requests via protocols not implemented by the user
       agent.

   gay

       A server which acts as an intermediary for some other server.
       Unlike a proxy, a gateway receives rets as if it were the
       origin server for the requested resource; the requesting client
       may not be aware tht is communicating with a gateway.
       Gateways are often used as server-side portals through network
       firewaand as protocol translators for access to resources
       stored on non-HTTP systems.

   tunnel

       A tunnel n intermediary program which is acting as a blind
       relay between two connections. Once active, a tunnel is not
   considered a party to the HTTP communication, though the tunnel
       may have been initiated by an HTTP request. Thnnel ceases to
       exist when both ends of the relayed connections are closed.
       Tunnels are used when a porta necessary and the intermediary
       cannot, or should not, interpret the relayed communication.

   cache

     program's local store of response messages and the subsystem
       that controls its message storage, retrieval, and dion. A
       cache stores cachable responses in order to reduce the response
       time and network bandwidth consumn on future, equivalent
       requests. Any client or server may include a cache, though a
       cache cannot be use a server while it is acting as a tunnel.

   Any given program may be capable of being both a client and a server;
 r use of these terms refers only to the role being performed by the
   program for a particular connection, rather thanthe program's
   capabilities in general. Likewise, any server may act as an origin
   server, proxy, gateway, or tunnswitching behavior based on the
   nature of each request.

1.3  Overall Operation

   The HTTP protocol is based orequest/response paradigm. A client
   establishes a connection with a server and sends a request to the
   server in form of a request method, URI, and protocol version,
   followed by a MIME-like message containing request modifiers, ct
   information, and possible body content. The server responds with a



Berners-Lee, et al           Information                    [Page 6]

RFC 1945                        HTTP/1.0                        May 1996


   statuse, including the message's protocol version and a success
   or error code, followed by a MIME-like message containing er
   information, entity metainformation, and possible body content.

   Most HTTP communication is initiated by a uagent and consists of
   a request to be applied to a resource on some origin server. In the
   simplest case, this ma accomplished via a single connection (v)
   between the user agent (UA) and the origin server (O).

          requesain ------------------------>
       UA -------------------v------------------- O
          <----------------------- rnse chain

   A more complicated situation occurs when one or more intermediaries
   are present in the request/respochain. There are three common
   forms of intermediary: proxy, gateway, and tunnel. A proxy is a
   forwarding agent, iving requests for a URI in its absolute form,
   rewriting all or parts of the message, and forwarding the reformatted request toward the server identified by the URI. A gateway is a
   receiving agent, acting as a layer above some otherver(s) and, if
   necessary, translating the requests to the underlying server's
   protocol. A tunnel acts as a relaynt between two connections
   without changing the messages; tunnels are used when the
   communication needs to pass ugh an intermediary (such as a
   firewall) even when the intermediary cannot understand the contents
   of the messag

          request chain -------------------------------------->
       UA -----v----- A -----v----- B -----v----- C -v----- O
          <------------------------------------- response chain

   The figure above shows three intermedia (A, B, and C) between the
   user agent and origin server. A request or response message that
   travels the whole chmust pass through four separate connections.
   This distinction is important because some HTTP communication options
ay apply only to the connection with the nearest, non-tunnel
   neighbor, only to the end-points of the chain, or to alnnections
   along the chain. Although the diagram is linear, each participant may
   be engaged in multiple, simultan communications. For example, B
   may be receiving requests from many clients other than A, and/or
   forwarding requ to servers other than C, at the same time that it
   is handling A's request.

   Any party to the communication whis not acting as a tunnel may
   employ an internal cache for handling requests. The effect of a cache
   is that the rst/response chain is shortened if one of the
   participants along the chain has a cached response applicable to that
equest. The following illustrates the resulting chain if B has a



Berners-Lee, et al           Informational                  [Page 7]

RFC 1945                        HTTP/1.0                        May 1996


   cached copy ofearlier response from O (via C) for a request which
   has not been cached by UA or A.

          request chain ------>
       UA -----v----- A -----v----- B - - - - - - C - - - - - - O
          <--------- response chain

   Not allponses are cachable, and some requests may contain
   modifiers which place special requirements on cache behavior. Som  HTTP/1.0 applications use heuristics to describe what is or is not a
   "cachable" response, but these rules are not dardized.

   On the Internet, HTTP communication generally takes place over TCP/IP
   connections. The default port CP 80 [15], but other ports can be
   used. This does not preclude HTTP from being implemented on top of
   any other ocol on the Internet, or on other networks. HTTP only
   presumes a reliable transport; any protocol that provides such guarantees can be used, and the mapping of the HTTP/1.0 request and
   response structures onto the transport data unif the protocol in
   question is outside the scope of this specification.

   Except for experimental applications, cnt practice requires that
   the connection be established by the client prior to each request and
   closed by the se after sending the response. Both clients and
   servers should be aware that either party may close the connection
  maturely, due to user action, automated time-out, or program
   failure, and should handle such closing in a predictablshion. In
   any case, the closing of the connection by either or both parties
   always terminates the current requesegardless of its status.

1.4  HTTP and MIME

   HTTP/1.0 uses many of the constructs defined for MIME, as defined i  RFC 1521 [5]. Appendix C describes the ways in which the context of
   HTTP allows for different use of Internet Medipes than is
   typically found in Internet mail, and gives the rationale for those
   differences.

2.  Notational Cntions and Generic Grammar

2.1  Augmented BNF

   All of the mechanisms specified in this document are described in both prose and an augmented Backus-Naur Form (BNF) similar to that
   used by RFC 822 [7]. Implementors will need to bmiliar with the
   notation in order to understand this specification. The augmented BNF
   includes the following concts:




Berners-Lee, et al           Informational                      [Page 8]

RFC 1945                     TTP/1.0                        May 1996


   name = definition

       The name of a rule is simply the name itselfthout any
       enclosing "<" and ">") and is separated from its definition by
       the equal character "=". Whites is only significant in that
       indentation of continuation lines is used to indicate a rule
       definition thaans more than one line. Certain basic rules
       are in uppercase, such as SP, LWS, HT, CRLF, DIGIT, ALPHA, etc.
   Angle brackets are used within definitions whenever their
       presence will facilitate discerning the use of rule na

   "literal"

       Quotation marks surround literal text. Unless stated otherwise,
       the text is case-inseive.

   rule1 | rule2

       Elements separated by a bar ("I") are alternatives,
       e.g., "yes | no" will accyes or no.

   (rule1 rule2)

       Elements enclosed in parentheses are treated as a single
       element. Thus,lem (foo | bar) elem)" allows the token
       sequences "elem foo elem" and "elem bar elem".

   *rule

       Theracter "*" preceding an element indicates repetition. The
       full form is "<n>*<m>element" indicating at least <n> at
       most <m> occurrences of element. Default values are 0 and
       infinity so that "*(element)" allows any nu, including zero;
       "1*element" requires at least one; and "1*2element" allows one
       or two.

   [rule]
    Square brackets enclose optional elements; "[foo bar]" is
       equivalent to "*1(foo bar)".

   N rule

     ecific repetition: "<n>(element)" is equivalent to
       "<n>*<n>(element)"; that is, exactly <n> occurrences of
    element). Thus 2DIGIT is a 2-digit number, and 3ALPHA is a
       string of three alphabetic characters.




Berneee, et al           Informational                      [Page 9]

RFC 1945                        HTTP/1.0                    May 1996


   #rule

       A construct "#" is defined, similar to "*", for defining lists
       of eleme The full form is "<n>#<m>element" indicating at
       least <n> and at most <m> elements, each separated by one or
   more commas (",") and optional linear whitespace (LWS). This
       makes the usual form of lists very easy; a rule sas
       "( *LWS element *( *LWS "," *LWS element ))" can be shown as
       "1#element". Wherever this construct is , null elements are
       allowed, but do not contribute to the count of elements present.
       That is, "(element)(element)" is permitted, but counts as
       only two elements. Therefore, where at least one element is
       requi at least one non-null element must be present. Default
       values are 0 and infinity so that "#(element)" allows an      number, including zero; "1#element" requires at least one; and
       "1#2element" allows one or two.

   ; com

       A semi-colon, set off some distance to the right of rule text,
       starts a comment that continues to the of line. This is a
       simple way of including useful notes in parallel with the
       specifications.

   impl*LWS

       The grammar described by this specification is word-based.
       Except where noted otherwise, linear wspace (LWS) can be
       included between any two adjacent words (token or
       quoted-string), and between adjacenkens and delimiters
       (tspecials), without changing the interpretation of a field. At
       least one delimiter ecials) must exist between any two
       tokens, since they would otherwise be interpreted as a single
       token. ver, applications should attempt to follow "common
       form" when generating HTTP constructs, since there exist some     implementations that fail to accept anything beyond the common
       forms.

2.2  Basic Rules

   The followiules are used throughout this specification to
   describe basic parsing constructs. The US-ASCII coded character set
s defined by [17].

       OCTET          = <any 8-bit sequence of data>
       CHAR           = <any US-ASCII charac(octets 0 - 127)>
       UPALPHA        = <any US-ASCII uppercase letter "A".."Z">
       LOALPHA        = <any US-ASCowercase letter "a".."z">



Berners-Lee, et al           Informational                     [Page 10]

RFC 1945                    HTTP/1.0                        May 1996


       ALPHA          = UPALPHA | LOALPHA
       DIGIT      = <any US-ASCII digit "0".."9">
       CTL            = <any US-ASCII control character
                        (ts 0 - 31) and DEL (127)>
       CR             = <US-ASCII CR, carriage return (13)>
       LF             = <US-ASCI, linefeed (10)>
       SP             = <US-ASCII SP, space (32)>
       HT             = <US-ASCII HT, horizontal-ta)>
       <">            = <US-ASCII double-quote mark (34)>

   HTTP/1.0 defines the octet sequence CR LF as the endline marker
   for all protocol elements except the Entity-Body (see Appendix B for
   tolerant applications). The endline marker within an Entity-Body
   is defined by its associated media type, as described in Section 3.6.

       CR         = CR LF

   HTTP/1.0 headers may be folded onto multiple lines if each
   continuation line begins with a spor horizontal tab. All linear
   whitespace, including folding, has the same semantics as SP.

       LWS            RLF] 1*( SP | HT )

   However, folding of header lines is not expected by some
   applications, and should not be geted by HTTP/1.0 applications.

   The TEXT rule is only used for descriptive field contents and values
   that are notended to be interpreted by the message parser. Words
   of *TEXT may contain octets from character sets other than US-I.

       TEXT           = <any OCTET except CTLs,
                        but including LWS>

   Recipients of he field TEXT containing octets outside the US-
   ASCII character set may assume that they represent ISO-8859-1
   charrs.

   Hexadecimal numeric characters are used in several protocol elements.

       HEX            = "A" | "B" | " "D" | "E" | "F"
                      | "a" | "b" | "c" | "d" | "e" | "f" | DIGIT

   Many HTTP/1.0 header field valconsist of words separated by LWS
   or special characters. These special characters must be in a quoted
   string to sed within a parameter value.

       word           = token | quoted-string




Berners-Lee, et al           Inftional                     [Page 11]

RFC 1945                        HTTP/1.0                        May 1996


   token          = 1*<any CHAR except CTLs or tspecials>

       tspecials      = "(" | ")" | "<" | ">" | "@"
                  | "," | ";" | ":" | "\" | <">
                      | "/" | "[" | "]" | "?" | "="
                      | " "}" | SP | HT

   Comments may be included in some HTTP header fields by surrounding
   the comment text with parents. Comments are only allowed in
   fields containing "comment" as part of their field value definition.
   In all otheelds, parentheses are considered part of the field
   value.

       comment        = "(" *( ctext | comment ) ")"
   ctext          = <any TEXT excluding "(" and ")">

   A string of text is parsed as a single word if it is quoted us
   double-quote marks.

       quoted-string  = ( <"> *(qdtext) <"> )

       qdtext         = <any CHAR except <"> CTLs,
                        but including LWS>

   Single-character quoting using the backslash ("\") character is
   permitted in HTTP/1.0.

3.  Protocol Parameters

3.1  HTTP Version

   HTTP uses a "<major>.<minor>" numberinheme to indicate versions
   of the protocol. The protocol versioning policy is intended to allow
   the sender to inde the format of a message and its capacity for
   understanding further HTTP communication, rather than the features
 tained via that communication. No change is made to the version
   number for the addition of message components which ot affect
   communication behavior or which only add to extensible field values.
   The <minor> number is incrementedn the changes made to the
   protocol add features which do not change the general message parsing
   algorithm, but w may add to the message semantics and imply
   additional capabilities of the sender. The <major> number is
   increme when the format of a message within the protocol is
   changed.

   The version of an HTTP message is indicated by aTP-Version field
   in the first line of the message. If the protocol version is not
   specified, the recipient must me that the message is in the



Berners-Lee, et al           Informational                     [Page 12]

RFC 19                      HTTP/1.0                        May 1996


   simple HTTP/0.9 format.

       HTTP-Version   TTP" "/" 1*DIGIT "." 1*DIGIT

   Note that the major and minor numbers should be treated as separate
   integers and  each may be incremented higher than a single digit.
   Thus, HTTP/2.4 is a lower version than HTTP/2.13, which in turn
   lower than HTTP/12.3. Leading zeros should be ignored by recipients
   and never generated by senders.

   This dent defines both the 0.9 and 1.0 versions of the HTTP
   protocol. Applications sending Full-Request or Full-Response
essages, as defined by this specification, must include an HTTP-
   Version of "HTTP/1.0".

   HTTP/1.0 servers must:      o recognize the format of the Request-Line for HTTP/0.9 and
        HTTP/1.0 requests;

      o understand any d request in the format of HTTP/0.9 or
        HTTP/1.0;

      o respond appropriately with a message in the same prol
        version used by the client.

   HTTP/1.0 clients must:

      o recognize the format of the Status-Line HTTP/1.0 responses;

      o understand any valid response in the format of HTTP/0.9 or
        HTTP/1.0.

   Proxy gateway applications must be careful in forwarding requests
   that are received in a format different than that of th  application's native HTTP version. Since the protocol version
   indicates the protocol capability of the sender, a p/gateway must
   never send a message with a version indicator which is greater than
   its native version; if a highersion request is received, the
   proxy/gateway must either downgrade the request version or respond
   with an error.uests with a version lower than that of the
   application's native format may be upgraded before being forwarded;
   proxy/gateway's response to that request must follow the server
   requirements listed above.







Berners-Let al           Informational                     [Page 13]

RFC 1945                        HTTP/1.0                    May 1996


3.2  Uniform Resource Identifiers

   URIs have been known by many names: WWW addresses, Universal Dont
   Identifiers, Universal Resource Identifiers [2], and finally the
   combination of Uniform Resource Locators (UR4] and Names (URN)
   [16]. As far as HTTP is concerned, Uniform Resource Identifiers are
   simply formatted strings h identify--via name, location, or any
   other characteristic--a network resource.

3.2.1 General Syntax

   URIs TTP can be represented in absolute form or relative to some
   known base URI [9], depending upon the context of their  The two
   forms are differentiated by the fact that absolute URIs always begin
   with a scheme name followed by a c.

       URI            = ( absoluteURI | relativeURI ) [ "#" fragment ]

       absoluteURI    = scheme ":" *( uch reserved )

       relativeURI    = net_path | abs_path | rel_path

       net_path       = "//" net_loc [ abs_path       abs_path       = "/" rel_path
       rel_path       = [ path ] [ ";" params ] [ "?" query ]

       path       = fsegment *( "/" segment )
       fsegment       = 1*pchar
       segment        = *pchar

       params         =am *( ";" param )
       param          = *( pchar | "/" )

       scheme         = 1*( ALPHA | DIGIT | "+" | "-" | "
       net_loc        = *( pchar | ";" | "?" )
       query          = *( uchar | reserved )
       fragment       =uchar | reserved )

       pchar          = uchar | ":" | "@" | "&" | "=" | "+"
       uchar          = unreserved | pe
       unreserved     = ALPHA | DIGIT | safe | extra | national

       escape         = "%" HEX HEX
       reser      = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+"
       extra          = "!" | "*" | "'" | "(" | ")" | ","
      e           = "$" | "-" | "_" | "."
       unsafe         = CTL | SP | <"> | "#" | "%" | "<" | ">"
       national     <any OCTET excluding ALPHA, DIGIT,



Berners-Lee, et al           Informational                     [Page 14]

1945                        HTTP/1.0                        May 1996


                        reserved, extra, safe, unsafe>

   For definitive information on URL syntax and semantics, see RFC 1738
   [4] and RFC 1808 [9]. The BNF abincludes national characters not
   allowed in valid URLs as specified by RFC 1738, since HTTP servers
   are not rested in the set of unreserved characters allowed to
   represent the rel_path part of addresses, and HTTP proxies may
  eive requests for URIs not defined by RFC 1738.

3.2.2 http URL

   The "http" scheme is used to locate network resos via the HTTP
   protocol. This section defines the scheme-specific syntax and
   semantics for http URLs.

       _URL       = "http:" "//" host [ ":" port ] [ abs_path ]

       host           = <A legal Internet host domain name
                     or IP address (in dotted-decimal form),
                         as defined by Section 2.1 of RFC >

       port           = *DIGIT

   If the port is empty or not given, port 80 is assumed. The semantics
   are tthe identified resource is located at the server listening
   for TCP connections on that port of that host, and the Ret-URI
   for the resource is abs_path. If the abs_path is not present in the
   URL, it must be given as "/" when useda Request-URI (Section
   5.1.2).

      Note: Although the HTTP protocol is independent of the transport
      layeotocol, the http URL only identifies resources by their
      TCP location, and thus non-TCP resources must be identifiy
      some other URI scheme.

   The canonical form for "http" URLs is obtained by converting any
   UPALPHA charas in host to their LOALPHA equivalent (hostnames are
   case-insensitive), eliding the [ ":" port ] if the port is 80, 
   replacing an empty abs_path with "/".

3.3  Date/Time Formats

   HTTP/1.0 applications have historically alloweree different
   formats for the representation of date/time stamps:

       Sun, 06 Nov 1994 08:49:37 GMT    ; RFC 8updated by RFC 1123
       Sunday, 06-Nov-94 08:49:37 GMT   ; RFC 850, obsoleted by RFC 1036
       Sun Nov  6 08:49:394         ; ANSI C's asctime() format



Berners-Lee, et al           Informational                     [Page 15]
FC 1945                        HTTP/1.0                        May 1996


   The first format is preferred as an Inte standard and represents
   a fixed-length subset of that defined by RFC 1123 [6] (an update to
   RFC 822 [7]). The sd format is in common use, but is based on the
   obsolete RFC 850 [10] date format and lacks a four-digit year.
   HT.0 clients and servers that parse the date value should accept
   all three formats, though they must never generate third
   (asctime) format.

      Note: Recipients of date values are encouraged to be robust in
      accepting date es that may have been generated by non-HTTP
      applications, as is sometimes the case when retrieving or posting
  messages via proxies/gateways to SMTP or NNTP.

   All HTTP/1.0 date/time stamps must be represented in Universal Time (UT), also known as Greenwich Mean Time (GMT), without exception.
   This is indicated in the first two formats by thelusion of "GMT"
   as the three-letter abbreviation for time zone, and should be assumed
   when reading the asctime ft.

       HTTP-date      = rfc1123-date | rfc850-date | asctime-date

       rfc1123-date   = wkday "," SP date1 SPe SP "GMT"
       rfc850-date    = weekday "," SP date2 SP time SP "GMT"
       asctime-date   = wkday SP date3 SP tim 4DIGIT

       date1          = 2DIGIT SP month SP 4DIGIT
                        ; day month year (e.g., 02 Jun 198       date2          = 2DIGIT "-" month "-" 2DIGIT
                        ; day-month-year (e.g., 02-Jun-82)
       3          = month SP ( 2DIGIT | ( SP 1DIGIT ))
                        ; month day (e.g., Jun  2)

       time       = 2DIGIT ":" 2DIGIT ":" 2DIGIT
                        ; 00:00:00 - 23:59:59

       wkday          = "Mon" | "Tue" ed"
                      | "Thu" | "Fri" | "Sat" | "Sun"

       weekday        = "Monday" | "Tuesday" | "Wednesday"                    | "Thursday" | "Friday" | "Saturday" | "Sunday"

       month          = "Jan" | "Feb" | "Mar" | "
                      | "May" | "Jun" | "Jul" | "Aug"
                      | "Sep" | "Oct" | "Nov" | "Dec"

      e: HTTP requirements for the date/time stamp format apply
       only to their usage within the protocol stream. Clientd
       servers are not required to use these formats for user



Berners-Lee, et al           Informational                 [Page 16]

RFC 1945                        HTTP/1.0                        May 1996


       presentatirequest logging, etc.

3.4  Character Sets

   HTTP uses the same definition of the term "character set" as that
  cribed for MIME:

      The term "character set" is used in this document to refer to a
      method used with one ore tables to convert a sequence of
      octets into a sequence of characters. Note that unconditional
      conversionthe other direction is not required, in that not all
      characters may be available in a given character set and a
  character set may provide more than one sequence of octets to
      represent a particular character. This definitionintended to
      allow various kinds of character encodings, from simple single-
      table mappings such as US-ASCI complex table switching methods
      such as those that use ISO 2022's techniques. However, the
      definition assted with a MIME character set name must fully
      specify the mapping to be performed from octets to characters. In
  particular, use of external profiling information to determine the
      exact mapping is not permitted.

      Nothis use of the term "character set" is more commonly
      referred to as a "character encoding." However, since HTTP a      MIME share the same registry, it is important that the terminology
      also be shared.

   HTTP character sete identified by case-insensitive tokens. The
   complete set of tokens are defined by the IANA Character Set registry
15]. However, because that registry does not define a single,
   consistent token for each character set, we define here preferred
   names for those character sets most likely to be used with HTTP
   entities. These character sets incluhose registered by RFC 1521
   [5] -- the US-ASCII [17] and ISO-8859 [18] character sets -- and
   other names specifiy recommended for use within MIME charset
   parameters.

     charset = "US-ASCII"
             | "ISO-8859-1" | "I859-2" | "ISO-8859-3"
             | "ISO-8859-4" | "ISO-8859-5" | "ISO-8859-6"
             | "ISO-8859-7" | "ISO-885 | "ISO-8859-9"
             | "ISO-2022-JP" | "ISO-2022-JP-2" | "ISO-2022-KR"
             | "UNICODE-1-1" | "UNICODE-UTF-7" | "UNICODE-1-1-UTF-8"
             | token

   Although HTTP allows an arbitrary token to be used as a charse  value, any token that has a predefined value within the IANA
   Character Set registry [15] must represent the characset defined



Berners-Lee, et al           Informational                     [Page 17]

RFC 1945                    HTTP/1.0                        May 1996


   by that registry. Applications should limit their use of charactersets to those defined by the IANA registry.

   The character set of an entity body should be labelled as the lowest
ommon denominator of the character codes used within that body, with
   the exception that no label is preferred over tabels US-ASCII or
   ISO-8859-1.

3.5  Content Codings

   Content coding values are used to indicate an encoding tformation
   that has been applied to a resource. Content codings are primarily
   used to allow a document to be comped or encrypted without losing
   the identity of its underlying media type. Typically, the resource is
   stored in tencoding and only decoded before rendering or
   analogous usage.

       content-coding = "x-gzip" | "x-compress" | n

       Note: For future compatibility, HTTP/1.0 applications should
       consider "gzip" and "compress" to be eqlent to "x-gzip"
       and "x-compress", respectively.

   All content-coding values are case-insensitive. HTTP/1.0 
   content-coding values in the Content-Encoding (Section 10.3) header
   field. Although the value describes the con-coding, what is more
   important is that it indicates what decoding mechanism will be
   required to remove the enco. Note that a single program may be
   capable of decoding multiple content-coding formats. Two values are
   defined his specification:

   x-gzip
       An encoding format produced by the file compression program
       "gzip" (GNU  developed by Jean-loup Gailly. This format is
       typically a Lempel-Ziv coding (LZ77) with a 32 bit CRC.

   x-cess
       The encoding format produced by the file compression program
       "compress". This format is an adaptive el-Ziv-Welch coding
       (LZW).

       Note: Use of program names for the identification of
       encoding formas not desirable and should be discouraged
       for future encodings. Their use here is representative of
       histal practice, not good design.






Berners-Lee, et al           Informational                     [Page 18]

1945                        HTTP/1.0                        May 1996


3.6  Media Types

   HTTP uses Internet Medipes [13] in the Content-Type header field
   (Section 10.5) in order to provide open and extensible data typing.

   media-type     = type "/" subtype *( ";" parameter )
       type           = token
       subtype        = token

  ameters may follow the type/subtype in the form of attribute/value
   pairs.

       parameter      = attribute "=" v
       attribute      = token
       value          = token | quoted-string

   The type, subtype, and parameter atute names are case-
   insensitive. Parameter values may or may not be case-sensitive,
   depending on the semantics oe parameter name. LWS must not be
   generated between the type and subtype, nor between an attribute and
   its valueon receipt of a media type with an unrecognized
   parameter, a user agent should treat the media type as if the
   ungnized parameter and its value were not present.

   Some older HTTP applications do not recognize media type paramete
   HTTP/1.0 applications should only use media type parameters when they
   are necessary to define the content of a mge.

   Media-type values are registered with the Internet Assigned Number
   Authority (IANA [15]). The media type rtration process is
   outlined in RFC 1590 [13]. Use of non-registered media types is
   discouraged.

3.6.1 Canonication and Text Defaults

   Internet media types are registered with a canonical form. In
   general, an Entity-Body sferred via HTTP must be represented in
   the appropriate canonical form prior to its transmission. If the body
   haen encoded with a Content-Encoding, the underlying data should
   be in canonical form prior to being encoded.

   Mesubtypes of the "text" type use CRLF as the text line break
   when in canonical form. However, HTTP allows the transpof text
   media with plain CR or LF alone representing a line break when used
   consistently within the Entity-Body.  applications must accept
   CRLF, bare CR, and bare LF as being representative of a line break in
   text media receivia HTTP.




Berners-Lee, et al           Informational                     [Page 19]

RFC 1945                    HTTP/1.0                        May 1996


   In addition, if the text media is represented in a character set th   does not use octets 13 and 10 for CR and LF respectively, as is the
   case for some multi-byte character sets, HTTPows the use of
   whatever octet sequences are defined by that character set to
   represent the equivalent of CR and or line breaks. This
   flexibility regarding line breaks applies only to text media in the
   Entity-Body; a bare CR F should not be substituted for CRLF
   within any of the HTTP control structures (such as header fields and
   multipboundaries).

   The "charset" parameter is used with some media types to define the
   character set (Section 3.4) oe data. When no explicit charset
   parameter is provided by the sender, media subtypes of the "text"
   type are defito have a default charset value of "ISO-8859-1" when
   received via HTTP. Data in character sets other than "ISO-8859-r
   its subsets must be labelled with an appropriate charset value in
   order to be consistently interpreted by the pient.

      Note: Many current HTTP servers provide data using charsets other
      than "ISO-8859-1" without propebelling. This situation reduces
      interoperability and is not recommended. To compensate for this,
      some HTTPr agents provide a configuration option to allow the
      user to change the default interpretation of the media type   character set when no charset parameter is given.

3.6.2 Multipart Types

   MIME provides for a number of "multi" types -- encapsulations of
   several entities within a single message's Entity-Body. The multipart
   types registeby IANA [15] do not have any special meaning for
   HTTP/1.0, though user agents may need to understand each type in
 der to correctly interpret the purpose of each body-part. An HTTP
   user agent should follow the same or similar behavas a MIME user
   agent does upon receipt of a multipart type. HTTP servers should not
   assume that all HTTP clients prepared to handle multipart types.

   All multipart types share a common syntax and must include a boundary
   parer as part of the media type value. The message body is itself
   a protocol element and must therefore use only CRLF tpresent line
   breaks between body-parts. Multipart body-parts may contain HTTP
   header fields which are significan the meaning of that part.

3.7  Product Tokens

   Product tokens are used to allow communicating applications to
dentify themselves via a simple product token, with an optional
   slash and version designator. Most fields using prodtokens also
   allow subproducts which form a significant part of the application to



Berners-Lee, et al         formational                     [Page 20]

RFC 1945                        HTTP/1.0                        May 1996
   be listed, separated by whitespace. By convention, the products are
   listed in order of their significance for ideying the
   application.

       product         = token ["/" product-version]
       product-version = token

   ples:

       User-Agent: CERN-LineMode/2.15 libwww/2.17b3

       Server: Apache/0.8.4

   Product tokens should hort and to the point -- use of them for
   advertizing or other non-essential information is explicitly
   forbidden.hough any token character may appear in a product-
   version, this token should only be used for a version identifier(i.e., successive versions of the same product should only differ in
   the product-version portion of the product valu

4.  HTTP Message

4.1  Message Types

   HTTP messages consist of requests from client to server and responses
 om server to client.

       HTTP-message   = Simple-Request           ; HTTP/0.9 messages
                      | Si-Response
                      | Full-Request             ; HTTP/1.0 messages
                      | Full-Response
 Full-Request and Full-Response use the generic message format of RFC
   822 [7] for transferring entities. Both messagay include optional
   header fields (also known as "headers") and an entity body. The
   entity body is separated froe headers by a null line (i.e., a
   line with nothing preceding the CRLF).

       Full-Request   = Request-Line         ; Section 5.1
                        *( General-Header        ; Section 4.3
                         | Request-Hr        ; Section 5.2
                         | Entity-Header )       ; Section 7.1
                        CRLF
                    [ Entity-Body ]          ; Section 7.2

       Full-Response  = Status-Line              ; Section 6                        *( General-Header        ; Section 4.3
                         | Response-Header       ; Secti.2



Berners-Lee, et al           Informational                     [Page 21]

RFC 1945                        H1.0                        May 1996


                         | Entity-Header )       ; Section 7.1
                    CRLF
                        [ Entity-Body ]          ; Section 7.2

   Simple-Request and Simple-Response do nolow the use of any header
   information and are limited to a single request method (GET).

       Simple-Request  = " SP Request-URI CRLF

       Simple-Response = [ Entity-Body ]

   Use of the Simple-Request format is discouraged use it prevents
   the server from identifying the media type of the returned entity.

4.2  Message Headers

   HTTader fields, which include General-Header (Section 4.3),
   Request-Header (Section 5.2), Response-Header (Section 6.2)d
   Entity-Header (Section 7.1) fields, follow the same generic format as
   that given in Section 3.1 of RFC 822 [7]ch header field consists
   of a name followed immediately by a colon (":"), a single space (SP)
   character, and theld value. Field names are case-insensitive.
   Header fields can be extended over multiple lines by preceding each
   a line with at least one SP or HT, though this is not
   recommended.

       HTTP-header    = field-name ":" [ fieldue ] CRLF

       field-name     = token
       field-value    = *( field-content | LWS )

       field-content  =  OCTETs making up the field-value
                        and consisting of either *TEXT or combinations
                    of token, tspecials, and quoted-string>

   The order in which header fields are received is not significant.
owever, it is "good practice" to send General-Header fields first,
   followed by Request-Header or Response-Header fieprior to the
   Entity-Header fields.

   Multiple HTTP-header fields with the same field-name may be present
   in ssage if and only if the entire field-value for that header
   field is defined as a comma-separated list [i.e., #(valu. It must
   be possible to combine the multiple header fields into one "field-
   name: field-value" pair, without chng the semantics of the
   message, by appending each subsequent field-value to the first, each
   separated by a comm



Berners-Lee, et al           Informational                     [Page 22]

RFC 1945                        HTT0                        May 1996


4.3  General Header Fields

   There are a few header fields which have generallicability for
   both request and response messages, but which do not apply to the
   entity being transferred. Theseders apply only to the message
   being transmitted.

       General-Header = Date                     ; Section 10.6                    | Pragma                   ; Section 10.12

   General header field names can be extended reliablyy in
   combination with a change in the protocol version. However, new or
   experimental header fields may be given semantics of general
   header fields if all parties in the communication recognize them to
   be general header fieldnrecognized header fields are treated as
   Entity-Header fields.

5. Request

   A request message from a client tserver includes, within the
   first line of that message, the method to be applied to the resource,
   the identifierthe resource, and the protocol version in use. For
   backwards compatibility with the more limited HTTP/0.9 protocol,there are two valid formats for an HTTP request:

       Request        = Simple-Request | Full-Request

       Simpequest = "GET" SP Request-URI CRLF

       Full-Request   = Request-Line             ; Section 5.1
                    *( General-Header        ; Section 4.3
                         | Request-Header        ; Section 5.2
                     | Entity-Header )       ; Section 7.1
                        CRLF
                        [ Entity-Body ]      ; Section 7.2

   If an HTTP/1.0 server receives a Simple-Request, it must respond with
   an HTTP/0.9 Simple-ResponAn HTTP/1.0 client capable of receiving
   a Full-Response should never generate a Simple-Request.

5.1  Request-Line   The Request-Line begins with a method token, followed by the
   Request-URI and the protocol version, and ending witLF. The
   elements are separated by SP characters. No CR or LF are allowed
   except in the final CRLF sequence.

   Request-Line = Method SP Request-URI SP HTTP-Version CRLF



Berners-Lee, et al           Informational                 [Page 23]

RFC 1945                        HTTP/1.0                        May 1996


   Note that the diffee between a Simple-Request and the Request-
   Line of a Full-Request is the presence of the HTTP-Version field and
   availability of methods other than GET.

5.1.1 Method

   The Method token indicates the method to be performed on resource
   identified by the Request-URI. The method is case-sensitive.

       Method         = "GET"                ; Section 8.1
                      | "HEAD"                   ; Section 8.2
                      | "POST"               ; Section 8.3
                      | extension-method

       extension-method = token

   The list of methocceptable by a specific resource can change
   dynamically; the client is notified through the return code of the
   rnse if a method is not allowed on a resource. Servers should
   return the status code 501 (not implemented) if the metis
   unrecognized or not implemented.

   The methods commonly used by HTTP/1.0 applications are fully defined
   iction 8.

5.1.2 Request-URI

   The Request-URI is a Uniform Resource Identifier (Section 3.2) and
   identifies thsource upon which to apply the request.

       Request-URI    = absoluteURI | abs_path

   The two options for RequURI are dependent on the nature of the
   request.

   The absoluteURI form is only allowed when the request is beinge
   to a proxy. The proxy is requested to forward the request and return
   the response. If the request is GET or HEnd a prior response is
   cached, the proxy may use the cached message if it passes any
   restrictions in the Expiresder field. Note that the proxy may
   forward the request on to another proxy or directly to the server
   specified be absoluteURI. In order to avoid request loops, a
   proxy must be able to recognize all of its server names, including any aliases, local variations, and the numeric IP address. An example
   Request-Line would be:

       GET http://w3.org/pub/WWW/TheProject.html HTTP/1.0




Berners-Lee, et al           Informational                     [Page 24]
RFC 1945                        HTTP/1.0                        May 1996


   The most common form of Request-URI ist used to identify a
   resource on an origin server or gateway. In this case, only the
   absolute path of the URI isnsmitted (see Section 3.2.1,
   abs_path). For example, a client wishing to retrieve the resource
   above directly frhe origin server would create a TCP connection
   to port 80 of the host "www.w3.org" and send the line:

       GET /WWW/TheProject.html HTTP/1.0

   followed by the remainder of the Full-Request. Note that the absolute
   path canno empty; if none is present in the original URI, it must
   be given as "/" (the server root).

   The Request-URI is smitted as an encoded string, where some
   characters may be escaped using the "% HEX HEX" encoding defined by
   RFC8 [4]. The origin server must decode the Request-URI in order
   to properly interpret the request.

5.2  Request HeaFields

   The request header fields allow the client to pass additional
   information about the request, and about client itself, to the
   server. These fields act as request modifiers, with semantics
   equivalent to the parametersa programming language method
   (procedure) invocation.

       Request-Header = Authorization            ; Section 
                      | From                     ; Section 10.8
                      | If-Modified-Since        ; Sen 10.9
                      | Referer                  ; Section 10.13
                      | User-Agent             Section 10.15

   Request-Header field names can be extended reliably only in
   combination with a change in the prol version. However, new or
   experimental header fields may be given the semantics of request
   header fields if alrties in the communication recognize them to
   be request header fields. Unrecognized header fields are treated as
  ity-Header fields.

6.  Response

   After receiving and interpreting a request message, a server responds
   in thrm of an HTTP response message.

       Response        = Simple-Response | Full-Response

       Simple-Response = tity-Body ]




Berners-Lee, et al           Informational                     [Page 25]

RFC 1945                    HTTP/1.0                        May 1996


       Full-Response   = Status-Line             ; Section 6.1
                     *( General-Header       ; Section 4.3
                          | Response-Header      ; Section 6.2
                      | Entity-Header )      ; Section 7.1
                         CRLF
                         [ En-Body ]         ; Section 7.2

   A Simple-Response should only be sent in response to an HTTP/0.9
   Simple-Request f the server only supports the more limited
   HTTP/0.9 protocol. If a client sends an HTTP/1.0 Full-Request and
   rees a response that does not begin with a Status-Line, it should
   assume that the response is a Simple-Response and pait
   accordingly. Note that the Simple-Response consists only of the
   entity body and is terminated by the server cng the connection.

6.1  Status-Line

   The first line of a Full-Response message is the Status-Line,
   consistin the protocol version followed by a numeric status code
   and its associated textual phrase, with each element separaty SP
   characters. No CR or LF is allowed except in the final CRLF sequence.

       Status-Line = HTTP-Version SP Ss-Code SP Reason-Phrase CRLF

   Since a status line always begins with the protocol version and
   status code

   "HTTP/" 1*DIGIT "." 1*DIGIT SP 3DIGIT SP

   (e.g., "HTTP/1.0 200 "), the presence of that expression is
   sufficieo differentiate a Full-Response from a Simple-Response.
   Although the Simple-Response format may allow such an expres to
   occur at the beginning of an entity body, and thus cause a
   misinterpretation of the message if it was given esponse to a
   Full-Request, most HTTP/0.9 servers are limited to responses of type
   "text/html" and therefore woulver generate such a response.

6.1.1 Status Code and Reason Phrase

   The Status-Code element is a 3-digit integer lt code of the
   attempt to understand and satisfy the request. The Reason-Phrase is
   intended to give a short textdescription of the Status-Code. The
   Status-Code is intended for use by automata and the Reason-Phrase is
   intender the human user. The client is not required to examine or
   display the Reason-Phrase.






Berners-Lee, et a        Informational                     [Page 26]

RFC 1945                        HTTP/1.0                        1996


   The first digit of the Status-Code defines the class of response. The
   last two digits do not have any corization role. There are 5
   values for the first digit:

      o 1xx: Informational - Not used, but reserved for fe use

      o 2xx: Success - The action was successfully received,
             understood, and accepted.

      o: Redirection - Further action must be taken in order to
             complete the request

      o 4xx: Client Errorhe request contains bad syntax or cannot
             be fulfilled

      o 5xx: Server Error - The server failed to ill an apparently
             valid request

   The individual values of the numeric status codes defined for
   HT.0, and an example set of corresponding Reason-Phrase's, are
   presented below. The reason phrases listed here are onlcommended
   -- they may be replaced by local equivalents without affecting the
   protocol. These codes are fully def in Section 9.

       Status-Code    = "200"   ; OK
                      | "201"   ; Created
                     202"   ; Accepted
                      | "204"   ; No Content
                      | "301"   ; Moved Permanently
                  | "302"   ; Moved Temporarily
                      | "304"   ; Not Modified
                      | "   ; Bad Request
                      | "401"   ; Unauthorized
                      | "403"   ; Forbidden
                  | "404"   ; Not Found
                      | "500"   ; Internal Server Error
                      | "501"  ot Implemented
                      | "502"   ; Bad Gateway
                      | "503"   ; Service Unavailable
                  | extension-code

       extension-code = 3DIGIT

       Reason-Phrase  = *<TEXT, excluding CR, LF>  HTTP status codes are extensible, but the above codes are the only
   ones generally recognized in current practice.  applications are
   not required to understand the meaning of all registered status



Berners-Lee, et al         formational                     [Page 27]

RFC 1945                        HTTP/1.0                        May 1996
   codes, though such understanding is obviously desirable. However,
   applications must understand the class of any ss code, as
   indicated by the first digit, and treat any unrecognized response as
   being equivalent to the x00 statode of that class, with the
   exception that an unrecognized response must not be cached. For
   example, if an unreczed status code of 431 is received by the
   client, it can safely assume that there was something wrong with its
   rst and treat the response as if it had received a 400 status
   code. In such cases, user agents should present to the  the
   entity returned with the response, since that entity is likely to
   include human-readable information which  explain the unusual
   status.

6.2  Response Header Fields

   The response header fields allow the server to pasditional
   information about the response which cannot be placed in the Status-
   Line. These header fields give inftion about the server and about
   further access to the resource identified by the Request-URI.

       Response-Hea= Location                ; Section 10.11
                       | Server                  ; Section 10.14
                   | WWW-Authenticate        ; Section 10.16

   Response-Header field names can be extended reliably only in
  bination with a change in the protocol version. However, new or
   experimental header fields may be given the semantic response
   header fields if all parties in the communication recognize them to
    be response header fields. Unrecoed header fields are treated as
   Entity-Header fields.

7.  Entity

   Full-Request and Full-Response messages maansfer an entity within
   some requests and responses. An entity consists of Entity-Header
   fields and (usually) anity-Body. In this section, both sender and
   recipient refer to either the client or the server, depending on who
   s and who receives the entity.













Berners-Lee, et al           Informational                    ge 28]

RFC 1945                        HTTP/1.0                        May 1996


7.1  Entity Header Fields

  ity-Header fields define optional metainformation about the
   Entity-Body or, if no body is present, about the resourcentified
   by the request.

       Entity-Header  = Allow                    ; Section 10.1
                      |tent-Encoding         ; Section 10.3
                      | Content-Length           ; Section 10.4
                  | Content-Type             ; Section 10.5
                      | Expires                  ; Section 10.7
                  | Last-Modified            ; Section 10.10
                      | extension-header

       extension-header =P-header

   The extension-header mechanism allows additional Entity-Header fields
   to be defined without changing protocol, but these fields cannot
   be assumed to be recognizable by the recipient. Unrecognized header
   fields shobe ignored by the recipient and forwarded by proxies.

7.2  Entity Body

   The entity body (if any) sent with an HTequest or response is in
   a format and encoding defined by the Entity-Header fields.

       Entity-Body    = *OCTE
   An entity body is included with a request message only when the
   request method calls for one. The presence of anity body in a
   request is signaled by the inclusion of a Content-Length header field
   in the request message headeHTTP/1.0 requests containing an
   entity body must include a valid Content-Length header field.

   For response mess, whether or not an entity body is included with
   a message is dependent on both the request method and the response code. All responses to the HEAD request method must not include a
   body, even though the presence of entity header fs may lead one
   to believe they do. All 1xx (informational), 204 (no content), and
   304 (not modified) responses mnot include a body. All other
   responses must include an entity body or a Content-Length header
   field defined witvalue of zero (0).

7.2.1 Type

   When an Entity-Body is included with a message, the data type of that
   body isermined via the header fields Content-Type and Content-
   Encoding. These define a two-layer, ordered encoding model:

Berners-Lee, et al           Informational                     [Page 29]

RFC 1945                        HTTP/1.0                    May 1996


       entity-body := Content-Encoding( Content-Type( data ) )

   A Content-Type spies the media type of the underlying data. A
   Content-Encoding may be used to indicate any additional content
   codapplied to the type, usually for the purpose of data
   compression, that is a property of the resource requested. Thedefault for the content encoding is none (i.e., the identity
   function).

   Any HTTP/1.0 message containing an entbody should include a
   Content-Type header field defining the media type of that body. If
   and only if the media tis not given by a Content-Type header, as
   is the case for Simple-Response messages, the recipient may attempt
   toss the media type via inspection of its content and/or the name
   extension(s) of the URL used to identify the resourcf the media
   type remains unknown, the recipient should treat it as type
   "application/octet-stream".

7.2.2 Len

   When an Entity-Body is included with a message, the length of that
   body may be determined in one of two ways.  Content-Length header
   field is present, its value in bytes represents the length of the
   Entity-Body. Otherwise, body length is determined by the closing
   of the connection by the server.

   Closing the connection cannot be uso indicate the end of a
   request body, since it leaves no possibility for the server to send
   back a response. There, HTTP/1.0 requests containing an entity
   body must include a valid Content-Length header field. If a request
   cins an entity body and Content-Length is not specified, and the
   server does not recognize or cannot calculate the le from other
   fields, then the server should send a 400 (bad request) response.

      Note: Some older servers suppn invalid Content-Length when
      sending a document that contains server-side includes dynamically
      inserted ithe data stream. It must be emphasized that this
      will not be tolerated by future versions of HTTP. Unless the
  client knows that it is receiving a response from a compliant
      server, it should not depend on the Content-Length e being
      correct.

8.  Method Definitions

   The set of common methods for HTTP/1.0 is defined below. Althoug  this set can be expanded, additional methods cannot be assumed to
   share the same semantics for separately extendedents and servers.




Berners-Lee, et al           Informational                     [Page 30]

RFC 1945                    HTTP/1.0                        May 1996


8.1  GET

   The GET method means retrieve whatever informat(in the form of an
   entity) is identified by the Request-URI. If the Request-URI refers
   to a data-producing proceit is the produced data which shall be
   returned as the entity in the response and not the source text of the
   pro, unless that text happens to be the output of the process.

   The semantics of the GET method changes to a "conditioGET" if the
   request message includes an If-Modified-Since header field. A
   conditional GET method requests that tdentified resource be
   transferred only if it has been modified since the date given by the
   If-Modified-Since hea as described in Section 10.9. The
   conditional GET method is intended to reduce network usage by
   allowing cachedities to be refreshed without requiring multiple
   requests or transferring unnecessary data.

8.2  HEAD

   The Hmethod is identical to GET except that the server must not
   return any Entity-Body in the response. The metainformationtained
   in the HTTP headers in response to a HEAD request should be identical
   to the information sent in respono a GET request. This method can
   be used for obtaining metainformation about the resource identified
   by the RequURI without transferring the Entity-Body itself. This
   method is often used for testing hypertext links for validity, accessibility, and recent modification.

   There is no "conditional HEAD" request analogous to the conditional
   GIf an If-Modified-Since header field is included with a HEAD
   request, it should be ignored.

8.3  POST

   The Pmethod is used to request that the destination server accept
   the entity enclosed in the request as a new subordinatethe
   resource identified by the Request-URI in the Request-Line. POST is
   designed to allow a uniform method to cothe following functions:

      o Annotation of existing resources;

      o Posting a message to a bulletin board, group, mailing list,
        or similar group of articles;

      o Providing a block of data, such as the result of itting a
        form [3], to a data-handling process;

      o Extending a database through an append operation.

Berners-Lee, et al           Informational                     [Page 31]

RFC 1945                        HTTP/1.0                    May 1996


   The actual function performed by the POST method is determined by the
   server and iually dependent on the Request-URI. The posted entity
   is subordinate to that URI in the same way that a file is suboate
   to a directory containing it, a news article is subordinate to a
   newsgroup to which it is posted, or a recor subordinate to a
   database.

   A successful POST does not require that the entity be created as a
   resource on origin server or made accessible for future
   reference. That is, the action performed by the POST method might not
esult in a resource that can be identified by a URI. In this case,
   either 200 (ok) or 204 (no content) is the apprope response
   status, depending on whether or not the response includes an entity
   that describes the result.

    resource has been created on the origin server, the response
   should be 201 (created) and contain an entity (preferaof type
   "text/html") which describes the status of the request and refers to
   the new resource.

   A valid Con-Length is required on all HTTP/1.0 POST requests. An
   HTTP/1.0 server should respond with a 400 (bad request) messag it
   cannot determine the length of the request message's content.

   Applications must not cache responses to a Prequest because the
   application has no way of knowing that the server would return an
   equivalent response on somture request.

9.  Status Code Definitions

   Each Status-Code is described below, including a description of which method(s) it can follow and any metainformation required in the
   response.

9.1  Informational 1xx

   This clas status code indicates a provisional response,
   consisting only of the Status-Line and optional headers, and is
   tnated by an empty line. HTTP/1.0 does not define any 1xx status
   codes and they are not a valid response to a HTTP/1.quest.
   However, they may be useful for experimental applications which are
   outside the scope of this specificati

9.2  Successful 2xx

   This class of status code indicates that the client's request was
   successfully receivedderstood, and accepted.




Berners-Lee, et al           Informational                     [Page 32]

RFC 1945                    HTTP/1.0                        May 1996


   200 OK

   The request has succeeded. The informatieturned with the
   response is dependent on the method used in the request, as follows:

   GET    an entity correspng to the requested resource is sent
          in the response;

   HEAD   the response must only contain the header rmation and
          no Entity-Body;

   POST   an entity describing or containing the result of the action.

   2reated

   The request has been fulfilled and resulted in a new resource being
   created. The newly created resource be referenced by the URI(s)
   returned in the entity of the response. The origin server should
   create the resourcfore using this Status-Code. If the action
   cannot be carried out immediately, the server must include in the
   rese body a description of when the resource will be available;
   otherwise, the server should respond with 202 (accepted
   Of the methods defined by this specification, only POST can create a
   resource.

   202 Accepted

   The req has been accepted for processing, but the processing
   has not been completed. The request may or may not eventually    acted upon, as it may be disallowed when processing actually takes
   place. There is no facility for re-sending a ss code from an
   asynchronous operation such as this.

   The 202 response is intentionally non-committal. Its purpos to
   allow a server to accept a request for some other process (perhaps
   a batch-oriented process that is only ruce per day) without
   requiring that the user agent's connection to the server persist
   until the process is comple The entity returned with this
   response should include an indication of the request's current
   status and either inter to a status monitor or some estimate of
   when the user can expect the request to be fulfilled.

   204 No Con

   The server has fulfilled the request but there is no new
   information to send back. If the client is a user ag it should
   not change its document view from that which caused the request to



Berners-Lee, et al           Inational                     [Page 33]

RFC 1945                        HTTP/1.0                        May 1996


e generated. This response is primarily intended to allow input
   for scripts or other actions to take place without cng a change
   to the user agent's active document view. The response may include
   new metainformation in the form otity headers, which should
   apply to the document currently in the user agent's active view.

9.3  Redirection 3xx  This class of status code indicates that further action needs to be
   taken by the user agent in order to fulfill thquest. The action
   required may be carried out by the user agent without interaction
   with the user if and only if method used in the subsequent
   request is GET or HEAD. A user agent should never automatically
   redirect a requesre than 5 times, since such redirections usually
   indicate an infinite loop.

   300 Multiple Choices

   This rese code is not directly used by HTTP/1.0 applications,
   but serves as the default for interpreting the 3xx class of
esponses.

   The requested resource is available at one or more locations.
   Unless it was a HEAD request, the resp should include an entity
   containing a list of resource characteristics and locations from
   which the user or useent can choose the one most appropriate.
   If the server has a preferred choice, it should include the URL in
   a Loon field; user agents may use this field value for
   automatic redirection.

   301 Moved Permanently

   The requd resource has been assigned a new permanent URL and
   any future references to this resource should be done using tha  URL. Clients with link editing capabilities should automatically
   relink references to the Request-URI to the new rence returned
   by the server, where possible.

   The new URL must be given by the Location field in the response.Unless it was a HEAD request, the Entity-Body of the response
   should contain a short note with a hyperlink to the neL.

   If the 301 status code is received in response to a request using
   the POST method, the user agent must not matically redirect the
   request unless it can be confirmed by the user, since this might
   change the conditions unwhich the request was issued.





Berners-Lee, et al           Informational                     [Page 34]

RF45                        HTTP/1.0                        May 1996


       Note: When automatically redirecting a POequest after
       receiving a 301 status code, some existing user agents will
       erroneously change it into a GEquest.

   302 Moved Temporarily

   The requested resource resides temporarily under a different URL.
   Since theirection may be altered on occasion, the client should
   continue to use the Request-URI for future requests.

   ThL must be given by the Location field in the response. Unless
   it was a HEAD request, the Entity-Body of the responseuld
   contain a short note with a hyperlink to the new URI(s).

   If the 302 status code is received in response toequest using
   the POST method, the user agent must not automatically redirect the
   request unless it can be confirby the user, since this might
   change the conditions under which the request was issued.

       Note: When automatly redirecting a POST request after
       receiving a 302 status code, some existing user agents will
       erroneouchange it into a GET request.

   304 Not Modified

   If the client has performed a conditional GET request and accis
   allowed, but the document has not been modified since the date and
   time specified in the If-Modified-Since fi the server must
   respond with this status code and not send an Entity-Body to the
   client. Header fields containe the response should only include
   information which is relevant to cache managers or which may have
   changed indeently of the entity's Last-Modified date. Examples
   of relevant header fields include: Date, Server, and Expires. A
ache should update its cached entity to reflect any new field
   values given in the 304 response.

9.4  Client Error

   The 4xx class of status code is intended for cases in which the
   client seems to have erred. If the client has completed the
   request when a 4xx code is received, it should immediately cease
   sending data to the server. Excehen responding to a HEAD request,
   the server should include an entity containing an explanation of the
   error siton, and whether it is a temporary or permanent
   condition. These status codes are applicable to any request method.




Berners-Lee, et al           Informational                     [Page 35]

RFC 1945                        HTT0                        May 1996


      Note: If the client is sending data, server implementations on TCP
      sd be careful to ensure that the client acknowledges receipt
      of the packet(s) containing the response prior to clo the
      input connection. If the client continues sending data to the
      server after the close, the server's coller will send a reset
      packet to the client, which may erase the client's unacknowledged
      input buffers befthey can be read and interpreted by the HTTP
      application.

   400 Bad Request

   The request could not be untood by the server due to malformed
   syntax. The client should not repeat the request without
   modifications.

 1 Unauthorized

   The request requires user authentication. The response must include
   a WWW-Authenticate header f (Section 10.16) containing a
   challenge applicable to the requested resource. The client may
   repeat the request  a suitable Authorization header field
   (Section 10.2). If the request already included Authorization
   credentialsen the 401 response indicates that authorization has
   been refused for those credentials. If the 401 response contain  the same challenge as the prior response, and the user agent has
   already attempted authentication at least once, tthe user
   should be presented the entity that was given in the response,
   since that entity may include relevant dostic information. HTTP
   access authentication is explained in Section 11.

   403 Forbidden

   The server underd the request, but is refusing to fulfill it.
   Authorization will not help and the request should not be repeated.
  the request method was not HEAD and the server wishes to make
   public why the request has not been fulfilled, it shodescribe
   the reason for the refusal in the entity body. This status code is
   commonly used when the server does nish to reveal exactly why
   the request has been refused, or when no other response is
   applicable.

   404 Not F

   The server has not found anything matching the Request-URI. No
   indication is given of whether the condition imporary or
   permanent. If the server does not wish to make this information
   available to the client, the status c403 (forbidden) can be
   used instead.



Berners-Lee, et al           Informational                     [Page 36]
RFC 1945                        HTTP/1.0                        May 1996


9.5  Server Error 5xx

   Response statodes beginning with the digit "5" indicate cases in
   which the server is aware that it has erred or is incapable of
erforming the request. If the client has not completed the request
   when a 5xx code is received, it should immediatelase sending data
   to the server. Except when responding to a HEAD request, the server
   should include an entity coning an explanation of the error
   situation, and whether it is a temporary or permanent condition.
   These responsees are applicable to any request method and there
   are no required header fields.

   500 Internal Server Error

he server encountered an unexpected condition which prevented it
   from fulfilling the request.

   501 Not Implemen

   The server does not support the functionality required to fulfill
   the request. This is the appropriate responsen the server does
   not recognize the request method and is not capable of supporting
   it for any resource.

   Bad Gateway

   The server, while acting as a gateway or proxy, received an invalid
   response from the upstream serit accessed in attempting to
   fulfill the request.

   503 Service Unavailable

   The server is currently unablehandle the request due to a
   temporary overloading or maintenance of the server. The implication
   is that this is mporary condition which will be alleviated
   after some delay.

       Note: The existence of the 503 status code doot imply
       that a server must use it when becoming overloaded. Some
       servers may wish to simply refuse the ection.

10.  Header Field Definitions

   This section defines the syntax and semantics of all commonly used
   HT.0 header fields. For general and entity header fields, both
   sender and recipient refer to either the client or the er,
   depending on who sends and who receives the message.




Berners-Lee, et al           Informational                 [Page 37]

RFC 1945                        HTTP/1.0                        May 1996


10.1  Allow

   Tllow entity-header field lists the set of methods supported by
   the resource identified by the Request-URI. The purpof this field
   is strictly to inform the recipient of valid methods associated with
   the resource. The Allow headerld is not permitted in a request
   using the POST method, and thus should be ignored if it is received
   as part of ST entity.

       Allow          = "Allow" ":" 1#method

    Example of use:

       Allow: GET, HEAD

   This d cannot prevent a client from trying other methods.
   However, the indications given by the Allow header field value ld
   be followed. The actual set of allowed methods is defined by the
   origin server at the time of each request.
 A proxy must not modify the Allow header field even if it does not
   understand all the methods specified, since the  agent may have
   other means of communicating with the origin server.

   The Allow header field does not indicate  methods are implemented
   by the server.

10.2  Authorization

   A user agent that wishes to authenticate itselfh a server--
   usually, but not necessarily, after receiving a 401 response--may do
   so by including an Authorizatiequest-header field with the
   request. The Authorization field value consists of credentials
   containing the autheation information of the user agent for the
   realm of the resource being requested.

       Authorization  = "Authotion" ":" credentials

   HTTP access authentication is described in Section 11. If a request
   is authenticated andealm specified, the same credentials should
   be valid for all other requests within this realm.

   Responses to rets containing an Authorization field are not
   cachable.







Berners-Lee, et al           Informational                 [Page 38]

RFC 1945                        HTTP/1.0                        May 1996


10.3  Content-Eing

   The Content-Encoding entity-header field is used as a modifier to the
   media-type. When present, its value cates what additional content
   coding has been applied to the resource, and thus what decoding
   mechanism must be ied in order to obtain the media-type
   referenced by the Content-Type header field. The Content-Encoding is
   prima used to allow a document to be compressed without losing
   the identity of its underlying media type.

       Contencoding = "Content-Encoding" ":" content-coding

   Content codings are defined in Section 3.5. An example of its use 
       Content-Encoding: x-gzip

   The Content-Encoding is a characteristic of the resource identified
   by the Rst-URI. Typically, the resource is stored with this
   encoding and is only decoded before rendering or analogous usage
10.4  Content-Length

   The Content-Length entity-header field indicates the size of the
   Entity-Body, in decimalber of octets, sent to the recipient or,
   in the case of the HEAD method, the size of the Entity-Body that
   would  been sent had the request been a GET.

       Content-Length = "Content-Length" ":" 1*DIGIT

   An example is

   Content-Length: 3495

   Applications should use this field to indicate the size of the
   Entity-Body to be transfe, regardless of the media type of the
   entity. A valid Content-Length field value is required on all
   HTTP/1.0 req messages containing an entity body.

   Any Content-Length greater than or equal to zero is a valid value.
   Sectio2.2 describes how to determine the length of a response
   entity body if a Content-Length is not given.

      Note: meaning of this field is significantly different from
      the corresponding definition in MIME, where it is an optio
      field used within the "message/external-body" content-type. In
      HTTP, it should be used whenever the entityength can be
      determined prior to being transferred.




Berners-Lee, et al           Informational                 [Page 39]

RFC 1945                        HTTP/1.0                        May 1996


10.5  Content-Type
The Content-Type entity-header field indicates the media type of the
   Entity-Body sent to the recipient or, in the caf the HEAD method,
   the media type that would have been sent had the request been a GET.

       Content-Type   = "ent-Type" ":" media-type

   Media types are defined in Section 3.6. An example of the field is

       Content-Typext/html

   Further discussion of methods for identifying the media type of an
   entity is provided in Section 7.2.1
10.6  Date

   The Date general-header field represents the date and time at which
   the message was originated, ha the same semantics as orig-date in
   RFC 822. The field value is an HTTP-date, as described in Section
   3.3.

   Date           = "Date" ":" HTTP-date

   An example is

       Date: Tue, 15 Nov 1994 08:12:31 GMT

   If a messis received via direct connection with the user agent
   (in the case of requests) or the origin server (in the case of responses), then the date can be assumed to be the current date at
   the receiving end. However, since the date--as i believed by the
   origin--is important for evaluating cached responses, origin servers
   should always include a Daeader. Clients should only send a Date
   header field in messages that include an entity body, as in the case
   of tOST request, and even then it is optional. A received message
   which does not have a Date header field should be assi one by the
   recipient if the message will be cached by that recipient or
   gatewayed via a protocol which requiresate.

   In theory, the date should represent the moment just before the
   entity is generated. In practice, the datn be generated at any
   time during the message origination without affecting its semantic
   value.

      Note: Arlier version of this document incorrectly specified
      that this field should contain the creation date of the encl
      Entity-Body. This has been changed to reflect actual (and proper)



Berners-Lee, et al           Informatio                    [Page 40]

RFC 1945                        HTTP/1.0                        May 1996


      us

10.7  Expires

   The Expires entity-header field gives the date/time after which the
   entity should be considestale. This allows information providers
   to suggest the volatility of the resource, or a date after which the
   ination may no longer be valid. Applications must not cache this
   entity beyond the date given. The presence of an Expifield does
   not imply that the original resource will change or cease to exist
   at, before, or after that time. Hor, information providers that
   know or even suspect that a resource will change by a certain date
   should include xpires header with that date. The format is an
   absolute date and time as defined by HTTP-date in Section 3.3.

   Expires        = "Expires" ":" HTTP-date

   An example of its use is

       Expires: Thu, 01 Dec 1994 16:00:00 GMT   If the date given is equal to or earlier than the value of the Date
   header, the recipient must not cache the encl entity. If a
   resource is dynamic by nature, as is the case with many data-
   producing processes, entities from tresource should be given an
   appropriate Expires value which reflects that dynamism.

   The Expires field cannot bed to force a user agent to refresh its
   display or reload a resource; its semantics apply only to caching
   mechan, and such mechanisms need only check a resource's
   expiration status when a new request for that resource is initiat

   User agents often have history mechanisms, such as "Back" buttons and
   history lists, which can be used to rediy an entity retrieved
   earlier in a session. By default, the Expires field does not apply to
   history mechanisms. he entity is still in storage, a history
   mechanism should display it even if the entity has expired, unless
   the  has specifically configured the agent to refresh expired
   history documents.

      Note: Applications are encourato be tolerant of bad or
      misinformed implementations of the Expires header. A value of zero
      (0) or an invadate format should be considered equivalent to
      an "expires immediately." Although these values are not legitimate    for HTTP/1.0, a robust implementation is always desirable.






Berners-Lee, et al           Informational                 [Page 41]

RFC 1945                        HTTP/1.0                        May 1996


10.8  From
The From request-header field, if given, should contain an Internet
   e-mail address for the human user who controls tequesting user
   agent. The address should be machine-usable, as defined by mailbox in
   RFC 822 [7] (as updated by 1123 [6]):

       From           = "From" ":" mailbox

   An example is:

       From: webmaster@w3.org

   Thiader field may be used for logging purposes and as a means for
   identifying the source of invalid or unwanted requestt should not
   be used as an insecure form of access protection. The interpretation
   of this field is that the requis being performed on behalf of the
   person given, who accepts responsibility for the method performed. In
   partic, robot agents should include this header so that the
   person responsible for running the robot can be contacted if pems
   occur on the receiving end.

   The Internet e-mail address in this field may be separate from the
   Internest which issued the request. For example, when a request
   is passed through a proxy, the original issuer's address sh be
   used.

      Note: The client should not send the From header field without the
      user's approval, as it conflict with the user's privacy
      interests or their site's security policy. It is strongly
      recommended thae user be able to disable, enable, and modify
      the value of this field at any time prior to a request.

10.9  Ifified-Since

   The If-Modified-Since request-header field is used with the GET
   method to make it conditional: if requested resource has not been
   modified since the time specified in this field, a copy of the
   resource will notreturned from the server; instead, a 304 (not
   modified) response will be returned without any Entity-Body.

      Modified-Since = "If-Modified-Since" ":" HTTP-date

   An example of the field is:

       If-Modified-Since: Sat, 2t 1994 19:43:31 GMT





Berners-Lee, et al           Informational                     [Page 42]

RFC 1945                    HTTP/1.0                        May 1996


   A conditional GET method requests that the identified rrce be
   transferred only if it has been modified since the date given by the
   If-Modified-Since header. The algorifor determining this includes
   the following cases:

      a) If the request would normally result in anything othean
         a 200 (ok) status, or if the passed If-Modified-Since date
         is invalid, the response is exactly thme as for a
         normal GET. A date which is later than the server's current
         time is invalid.

      b)the resource has been modified since the
         If-Modified-Since date, the response is exactly the same as
         a normal GET.

      c) If the resource has not been modified since a valid
         If-Modified-Since date, the sershall return a 304 (not
         modified) response.

   The purpose of this feature is to allow efficient updates ofhed
   information with a minimum amount of transaction overhead.

10.10  Last-Modified

   The Last-Modified entitader field indicates the date and time at
   which the sender believes the resource was last modified. The exact
   seics of this field are defined in terms of how the recipient
   should interpret it:  if the recipient has a copy of thisource
   which is older than the date given by the Last-Modified field, that
   copy should be considered stale.

   Last-Modified  = "Last-Modified" ":" HTTP-date

   An example of its use is

       Last-Modified: Tue, 15 Nov 199:45:26 GMT

   The exact meaning of this header field depends on the implementation
   of the sender and the nature oe original resource. For files, it
   may be just the file system last-modified time. For entities with
   dynamicallyluded parts, it may be the most recent of the set of
   last-modify times for its component parts. For database gatewayt
   may be the last-update timestamp of the record. For virtual objects,
   it may be the last time the internal statanged.

   An origin server must not send a Last-Modified date which is later
   than the server's time of message oration. In such cases, where
   the resource's last modification would indicate some time in the



Berners-Lee, et          Informational                     [Page 43]

RFC 1945                        HTTP/1.0                        1996


   future, the server must replace that date with the message
   origination date.

10.11  Location

   Location response-header field defines the exact location of the
   resource that was identified by the Request-URI. Fox responses,
   the location must indicate the server's preferred URL for automatic
   redirection to the resource. Onne absolute URL is allowed.

       Location       = "Location" ":" absoluteURI

   An example is

       Locationtp://www.w3.org/hypertext/WWW/NewLocation.html

10.12  Pragma

   The Pragma general-header field is used to includelementation-
   specific directives that may apply to any recipient along the
   request/response chain. All pragma diives specify optional
   behavior from the viewpoint of the protocol; however, some systems
   may require that behavie consistent with the directives.

       Pragma           = "Pragma" ":" 1#pragma-directive

       pragma-directiv"no-cache" | extension-pragma
       extension-pragma = token [ "=" word ]

   When the "no-cache" directive is presen a request message, an
   application should forward the request toward the origin server even
   if it has a cached  of what is being requested. This allows a
   client to insist upon receiving an authoritative response to its
   requ It also allows a client to refresh a cached copy which is
   known to be corrupted or stale.

   Pragma directives mbe passed through by a proxy or gateway
   application, regardless of their significance to that application,
   since directives may be applicable to all recipients along the
   request/response chain. It is not possible to specify a pr for a
   specific recipient; however, any pragma directive not relevant to a
   recipient should be ignored by that rient.

10.13  Referer

   The Referer request-header field allows the client to specify, for
   the server's benefihe address (URI) of the resource from which
   the Request-URI was obtained. This allows a server to generate lists

Berners-Lee, et al           Informational                     [Page 44]

RFC 1945                        HTTP/1.0                    May 1996


   of back-links to resources for interest, logging, optimized caching,
   etc. It also ws obsolete or mistyped links to be traced for
   maintenance. The Referer field must not be sent if the Request-URI
 s obtained from a source that does not have its own URI, such as
   input from the user keyboard.

       Referer    = "Referer" ":" ( absoluteURI | relativeURI )

   Example:

       Referer: http://www.w3.org/hypertext/DataSources/view.html

   If a partial URI is given, it should be interpreted relative to the
   Request-URI. The URI must not ine a fragment.

      Note: Because the source of a link may be private information or
      may reveal an otherwise pte information source, it is strongly
      recommended that the user be able to select whether or not the
      Referield is sent. For example, a browser client could have a
      toggle switch for browsing openly/anonymously, which wou      respectively enable/disable the sending of Referer and From
      information.

10.14  Server

   The Server onse-header field contains information about the
   software used by the origin server to handle the request. The field can contain multiple product tokens (Section 3.7) and comments
   identifying the server and any significant subproducBy
   convention, the product tokens are listed in order of their
   significance for identifying the application.

   Server         = "Server" ":" 1*( product | comment )

   Example:

       Server: CERN/3.0 libwww/2.17

   If response is being forwarded through a proxy, the proxy
   application must not add its data to the product list.

   ote: Revealing the specific software version of the server may
      allow the server machine to become more vulnerableattacks
      against software that is known to contain security holes. Server
      implementors are encouraged to mahis field a configurable
      option.





Berners-Lee, et al           Informational                     [Page 

RFC 1945                        HTTP/1.0                        May 1996


      Note: Some existing servers failrestrict themselves to the
      product token syntax within the Server field.

10.15  User-Agent

   The User-Agenquest-header field contains information about the
   user agent originating the request. This is for statistical purpos
   the tracing of protocol violations, and automated recognition of user
   agents for the sake of tailoring responsesavoid particular user
   agent limitations. Although it is not required, user agents should
   include this field withuests. The field can contain multiple
   product tokens (Section 3.7) and comments identifying the agent and
   any suducts which form a significant part of the user agent. By
   convention, the product tokens are listed in order of thei  significance for identifying the application.

       User-Agent     = "User-Agent" ":" 1*( product | comment )

 ample:

       User-Agent: CERN-LineMode/2.15 libwww/2.17b3

       Note: Some current proxy applications append theroduct
       information to the list in the User-Agent field. This is not
       recommended, since it makes machine rpretation of these
       fields ambiguous.

       Note: Some existing clients fail to restrict themselves to
    he product token syntax within the User-Agent field.

10.16  WWW-Authenticate

   The WWW-Authenticate response-headield must be included in 401
   (unauthorized) response messages. The field value consists of at
   least one challengat indicates the authentication scheme(s) and
   parameters applicable to the Request-URI.

       WWW-Authenticate =W-Authenticate" ":" 1#challenge

   The HTTP access authentication process is described in Section 11.
   User agentst take special care in parsing the WWW-Authenticate
   field value if it contains more than one challenge, or if more t
   one WWW-Authenticate header field is provided, since the contents of
   a challenge may itself contain a comma-sepad list of
   authentication parameters.






Berners-Lee, et al           Informational                     [Pa6]

RFC 1945                        HTTP/1.0                        May 1996


11.  Access Authentication

   HTrovides a simple challenge-response authentication mechanism
   which may be used by a server to challenge a client req and by a
   client to provide authentication information. It uses an extensible,
   case-insensitive token to identife authentication scheme,
   followed by a comma-separated list of attribute-value pairs which
   carry the parameters ssary for achieving authentication via that
   scheme.

       auth-scheme    = token

       auth-param     = toke" quoted-string

   The 401 (unauthorized) response message is used by an origin server
   to challenge the authoriza of a user agent. This response must
   include a WWW-Authenticate header field containing at least one
   challenge acable to the requested resource.

       challenge      = auth-scheme 1*SP realm *( "," auth-param )

       realm      = "realm" "=" realm-value
       realm-value    = quoted-string

   The realm attribute (case-insensitive) is reqd for all
   authentication schemes which issue a challenge. The realm value
   (case-sensitive), in combination with canonical root URL of the
   server being accessed, defines the protection space. These realms
   allow the protected urces on a server to be partitioned into a
   set of protection spaces, each with its own authentication scheme
   andauthorization database. The realm value is a string, generally
   assigned by the origin server, which may have additiosemantics
   specific to the authentication scheme.

   A user agent that wishes to authenticate itself with a server   usually, but not necessarily, after receiving a 401 response--may do
   so by including an Authorization header fielth the request. The
   Authorization field value consists of credentials containing the
   authentication information he user agent for the realm of the
   resource being requested.

       credentials    = basic-credentials
                  | ( auth-scheme #auth-param )

   The domain over which credentials can be automatically applied by a
   useent is determined by the protection space. If a prior request
   has been authorized, the same credentials may be reuser all other
   requests within that protection space for a period of time determined



Berners-Lee, et al         formational                     [Page 47]

RFC 1945                        HTTP/1.0                        May 1996
   by the authentication scheme, parameters, and/or user preference.
   Unless otherwise defined by the authentication me, a single
   protection space cannot extend outside the scope of its server.

   If the server does not wish to ac the credentials sent with a
   request, it should return a 403 (forbidden) response.

   The HTTP protocol does not rict applications to this simple
   challenge-response mechanism for access authentication. Additional
   mechanisms me used, such as encryption at the transport level or
   via message encapsulation, and with additional header fields
 ecifying authentication information. However, these additional
   mechanisms are not defined by this specification.

roxies must be completely transparent regarding user agent
   authentication. That is, they must forward the WWW-Authente and
   Authorization headers untouched, and must not cache the response to a
   request containing Authorization. H1.0 does not provide a means
   for a client to be authenticated with a proxy.

11.1  Basic Authentication Scheme

he "basic" authentication scheme is based on the model that the user
   agent must authenticate itself with a user-ID a password for each
   realm. The realm value should be considered an opaque string which
   can only be compared for eity with other realms on that server.
   The server will authorize the request only if it can validate the
   user-ID password for the protection space of the Request-URI.
   There are no optional authentication parameters.

   Upon ret of an unauthorized request for a URI within the
   protection space, the server should respond with a challenge like 
   following:

       WWW-Authenticate: Basic realm="WallyWorld"

   where "WallyWorld" is the string assigned by terver to identify
   the protection space of the Request-URI.

   To receive authorization, the client sends the userand password,
   separated by a single colon (":") character, within a base64 [5]
   encoded string in the credentials
       basic-credentials = "Basic" SP basic-cookie

       basic-cookie      = <base64 [5] encoding of userid-passwor                            except not limited to 76 char/line>




Berners-Lee, et al           Informational                 [Page 48]

RFC 1945                        HTTP/1.0                        May 1996


       userid-pard   = [ token ] ":" *TEXT

   If the user agent wishes to send the user-ID "Aladdin" and password
   "open sesame", ould use the following header field:

       Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==

   The basic authention scheme is a non-secure method of filtering
   unauthorized access to resources on an HTTP server. It is based on
 e assumption that the connection between the client and the server
   can be regarded as a trusted carrier. As this is generally true
   on an open network, the basic authentication scheme should be used
   accordingly. In spite of this,ents should implement the scheme in
   order to communicate with servers that use it.

12.  Security Considerations
 This section is meant to inform application developers, information
   providers, and users of the security limitation HTTP/1.0 as
   described by this document. The discussion does not include
   definitive solutions to the problems reed, though it does make
   some suggestions for reducing security risks.

12.1  Authentication of Clients

   As mened in Section 11.1, the Basic authentication scheme is not
   a secure method of user authentication, nor does it prevthe
   Entity-Body from being transmitted in clear text across the physical
   network used as the carrier. HTTP/1.0 dnot prevent additional
   authentication schemes and encryption mechanisms from being employed
   to increase security
12.2  Safe Methods

   The writers of client software should be aware that the software
   represents the user in thinteractions over the Internet, and
   should be careful to allow the user to be aware of any actions they
   may takech may have an unexpected significance to themselves or
   others.

   In particular, the convention has been establi that the GET and
   HEAD methods should never have the significance of taking an action
   other than retrieval. Thesthods should be considered "safe." This
   allows user agents to represent other methods, such as POST, in a
   speciay, so that the user is made aware of the fact that a
   possibly unsafe action is being requested.





Berners-Let al           Informational                     [Page 49]

RFC 1945                        HTTP/1.0                    May 1996


   Naturally, it is not possible to ensure that the server does not
   generate side-effects as a resof performing a GET request; in
   fact, some dynamic resources consider that a feature. The important
   distinction  is that the user did not request the side-effects,
   so therefore cannot be held accountable for them.

12.3  AbuseServer Log Information

   A server is in the position to save personal data about a user's
   requests which may idey their reading patterns or subjects of
   interest. This information is clearly confidential in nature and its
   hang may be constrained by law in certain countries. People using
   the HTTP protocol to provide data are responsible foruring that
   such material is not distributed without the permission of any
   individuals that are identifiable by tublished results.

12.4  Transfer of Sensitive Information

   Like any generic data transfer protocol, HTTP cannot late the
   content of the data that is transferred, nor is there any a priori
   method of determining the sensitivit any particular piece of
   information within the context of any given request. Therefore,
   applications should supas much control over this information as
   possible to the provider of that information. Three header fields are
   w special mention in this context: Server, Referer and From.

   Revealing the specific software version of the server allow the
   server machine to become more vulnerable to attacks against software
   that is known to contain securityes. Implementors should make the
   Server header field a configurable option.

   The Referer field allows reading prns to be studied and reverse
   links drawn. Although it can be very useful, its power can be abused
   if user detaire not separated from the information contained in
   the Referer. Even when the personal information has been removed,
   Referer field may indicate a private document's URI whose publication
   would be inappropriate.

   The informa sent in the From field might conflict with the user's
   privacy interests or their site's security policy, and hence    should not be transmitted without the user being able to disable,
   enable, and modify the contents of the field. Tser must be able
   to set the contents of this field within a user preference or
   application defaults configuratio
   We suggest, though do not require, that a convenient toggle interface
   be provided for the user to enable or dis the sending of From and
   Referer information.



Berners-Lee, et al           Informational                     e 50]

RFC 1945                        HTTP/1.0                        May 1996


12.5  Attacks Based On File and  Names

   Implementations of HTTP origin servers should be careful to restrict
   the documents returned by HTTP reqs to be only those that were
   intended by the server administrators. If an HTTP server translates
   HTTP URIs direcinto file system calls, the server must take
   special care not to serve files that were not intended to be
   deliveto HTTP clients. For example, Unix, Microsoft Windows, and
   other operating systems use ".." as a path component to iate a
   directory level above the current one. On such a system, an HTTP
   server must disallow any such construct ie Request-URI if it
   would otherwise allow access to a resource outside those intended to
   be accessible via the Hserver. Similarly, files intended for
   reference only internally to the server (such as access control
   files, conration files, and script code) must be protected from
   inappropriate retrieval, since they might contain sensitive
 formation. Experience has shown that minor bugs in such HTTP server
   implementations have turned into security risks.13.  Acknowledgments

   This specification makes heavy use of the augmented BNF and generic
   constructs defined byid H. Crocker for RFC 822 [7]. Similarly, it
   reuses many of the definitions provided by Nathaniel Borenstein and
   Freed for MIME [5]. We hope that their inclusion in this
   specification will help reduce past confusion over the relnship
   between HTTP/1.0 and Internet mail message formats.

   The HTTP protocol has evolved considerably over the  four years.
   It has benefited from a large and active developer community--the
   many people who have participatedthe www-talk mailing list--and
   it is that community which has been most responsible for the success
   of HTTP and he World-Wide Web in general. Marc Andreessen, Robert
   Cailliau, Daniel W. Connolly, Bob Denny, Jean-Francois Groff, lip
   M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob McCool, Lou
   Montulli, Dave Raggett, Tony Sanders, and Marc eyningen deserve
   special recognition for their efforts in defining aspects of the
   protocol for early versions ofs specification.

   Paul Hoffman contributed sections regarding the informational status
   of this document and Appces C and D.










Berners-Lee, et al           Informational                     [Page 51]

RFC 1945                    HTTP/1.0                        May 1996


   This document has benefited greatly from the comment all those
   participating in the HTTP-WG. In addition to those already mentioned,
   the following individuals have ributed to this specification:

       Gary Adams                         Harald Tveit Alvestrand
       Keith Ball                     Brian Behlendorf
       Paul Burchard                      Maurizio Codogno
       Mike Cowlishaw                 Roman Czyborra
       Michael A. Dolan                   John Franks
       Jim Gettys                     Marc Hedlund
       Koen Holtman                       Alex Hopmann
       Bob Jernigan                       Shelhan
       Martijn Koster                     Dave Kristol
       Daniel LaLiberte                   Paul Leach
     bert Lunde                       John C. Mallery
       Larry Masinter                     Mitra
       Jeffrey Mogul                  Gavin Nicol
       Bill Perry                         Jeffrey Perry
       Owen Rees                      Luigi Rizzo
       David Robinson                     Marc Salomon
       Rich Salz                          Jim man
       Chuck Shotton                      Eric W. Sink
       Simon E. Spero                     Robert S. Thau
   Francois Yergeau                   Mary Ellen Zurko
       Jean-Philippe Martin-Flatin

14. References

   [1]  Asaria, F., McCahill, M., Lindner, P., Johnson, D.,
        Torrey, D., and B. Alberti, "The Internet Gopher Protocol: A      Distributed Document Search and Retrieval Protocol", RFC 1436,
        University of Minnesota, March 1993.

    Berners-Lee, T., "Universal Resource Identifiers in WWW: A
        Unifying Syntax for the Expression of Names and Adses of
        Objects on the Network as used in the World-Wide Web",
        RFC 1630, CERN, June 1994.

   [3]  Bes-Lee, T., and D. Connolly, "Hypertext Markup Language -
        2.0", RFC 1866, MIT/W3C, November 1995.

   [4]  Ber-Lee, T., Masinter, L., and M. McCahill, "Uniform
        Resource Locators (URL)", RFC 1738, CERN, Xerox PARC,
      iversity of Minnesota, December 1994.







Berners-Lee, et al           Informational                     [Pag]

RFC 1945                        HTTP/1.0                        May 1996


   [5]  Borenstein, N., and N. FreedIME (Multipurpose Internet Mail
        Extensions) Part One: Mechanisms for Specifying and Describing
        the Forof Internet Message Bodies", RFC 1521, Bellcore,
        Innosoft, September 1993.

   [6]  Braden, R., "Requirements Internet hosts - Application and
        Support", STD 3, RFC 1123, IETF, October 1989.

   [7]  Crocker, D., "Standfor the Format of ARPA Internet Text
        Messages", STD 11, RFC 822, UDEL, August 1982.

   [8]  F. Davis, B. KahH. Morris, J. Salem, T. Shen, R. Wang,
        J. Sui, and M. Grinbaum. "WAIS Interface Protocol Prototype
        Funnal Specification." (v1.5), Thinking Machines
        Corporation, April 1990.

   [9]  Fielding, R., "Relative Unifoesource Locators", RFC 1808,
        UC Irvine, June 1995.

   [10] Horton, M., and R. Adams, "Standard for interchanf USENET
        Messages", RFC 1036 (Obsoletes RFC 850), AT&T Bell
        Laboratories, Center for Seismic Studies, mber 1987.

   [11] Kantor, B., and P. Lapsley, "Network News Transfer Protocol:
        A Proposed Standard for the am-Based Transmission of News",
        RFC 977, UC San Diego, UC Berkeley, February 1986.

   [12] Postel, J., "Simpail Transfer Protocol." STD 10, RFC 821,
        USC/ISI, August 1982.

   [13] Postel, J., "Media Type Registration edure." RFC 1590,
        USC/ISI, March 1994.

   [14] Postel, J., and J. Reynolds, "File Transfer Protocol (FTP)",     STD 9, RFC 959, USC/ISI, October 1985.

   [15] Reynolds, J., and J. Postel, "Assigned Numbers", STD 2, RFC
    1700, USC/ISI, October 1994.

   [16] Sollins, K., and L. Masinter, "Functional Requirements for
        Uniform Reso Names", RFC 1737, MIT/LCS, Xerox Corporation,
        December 1994.

   [17] US-ASCII. Coded Character Set - 7-Bit ican Standard Code
        for Information Interchange. Standard ANSI X3.4-1986, ANSI,
        1986.





Bernere, et al           Informational                     [Page 53]

RFC 1945                        HTTP/1.0                    May 1996


   [18] ISO-8859. International Standard -- Information Processing --
        8-bit Single-Byte CoGraphic Character Sets --
        Part 1: Latin alphabet No. 1, ISO 8859-1:1987.
        Part 2: Latin alphabet No. 2, 8859-2, 1987.
        Part 3: Latin alphabet No. 3, ISO 8859-3, 1988.
        Part 4: Latin alphabet No. 4, ISO 8859-988.
        Part 5: Latin/Cyrillic alphabet, ISO 8859-5, 1988.
        Part 6: Latin/Arabic alphabet, ISO 8859-6, 198        Part 7: Latin/Greek alphabet, ISO 8859-7, 1987.
        Part 8: Latin/Hebrew alphabet, ISO 8859-8, 1988.
     art 9: Latin alphabet No. 5, ISO 8859-9, 1990.

15.  Authors' Addresses

   Tim Berners-Lee
   Director, W3 Consort
   MIT Laboratory for Computer Science
   545 Technology Square
   Cambridge, MA 02139, U.S.A.

   Fax: +1 (617) 2582
   EMail: timbl@w3.org


   Roy T. Fielding
   Department of Information and Computer Science
   University of fornia
   Irvine, CA 92717-3425, U.S.A.

   Fax: +1 (714) 824-4056
   EMail: fielding@ics.uci.edu


   Henrik Fry Nielsen
   W3 Consortium
   MIT Laboratory for Computer Science
   545 Technology Square
   Cambridge, MA 02139, U.

   Fax: +1 (617) 258 8682
   EMail: frystyk@w3.org










Berners-Lee, et al           Informational                 [Page 54]

RFC 1945                        HTTP/1.0                        May 1996


Appendices
 These appendices are provided for informational reasons only -- they
   do not form a part of the HTTP/1.0 specificati

A.  Internet Media Type message/http

   In addition to defining the HTTP/1.0 protocol, this document serves
   as specification for the Internet media type "message/http". The
   following is to be registered with IANA [13].

    edia Type name:         message

       Media subtype name:      http

       Required parameters:     none

     tional parameters:     version, msgtype

              version: The HTTP-Version number of the enclosed message
                   (e.g., "1.0"). If not present, the version can be
                       determined from the first line oe body.

              msgtype: The message type -- "request" or "response". If
                       not present, type can be determined from the
                       first line of the body.

       Encoding considerations: only "", "8bit", or "binary" are
                                permitted

       Security considerations: none

B.  Tolt Applications

   Although this document specifies the requirements for the generation
   of HTTP/1.0 messages, not applications will be correct in their
   implementation. We therefore recommend that operational applications
   be tont of deviations whenever those deviations can be
   interpreted unambiguously.

   Clients should be tolerant in par the Status-Line and servers
   tolerant when parsing the Request-Line. In particular, they should
   accept any amoun SP or HT characters between fields, even though
   only a single SP is required.

   The line terminator for HTTP-he fields is the sequence CRLF.
   However, we recommend that applications, when parsing such headers,
   recognize a si LF as a line terminator and ignore the leading CR.



Berners-Lee, et al           Informational                   age 55]

RFC 1945                        HTTP/1.0                        May 1996


C.  Relationship to MIME

  P/1.0 uses many of the constructs defined for Internet Mail (RFC
   822 [7]) and the Multipurpose Internet Mail Extensi(MIME [5]) to
   allow entities to be transmitted in an open variety of
   representations and with extensible mechani However, RFC 1521
   discusses mail, and HTTP has a few features that are different than
   those described in RFC 15These differences were carefully chosen
   to optimize performance over binary connections, to allow greater
   freedo the use of new media types, to make date comparisons
   easier, and to acknowledge the practice of some early HTTP ser
   and clients.

   At the time of this writing, it is expected that RFC 1521 will be
   revised. The revisions maylude some of the practices found in
   HTTP/1.0 but not in RFC 1521.

   This appendix describes specific areas whereP differs from RFC
   1521. Proxies and gateways to strict MIME environments should be
   aware of these differences arovide the appropriate conversions
   where necessary. Proxies and gateways from MIME environments to HTTP
   also nee be aware of the differences because some conversions may
   be required.

C.1  Conversion to Canonical Form

   RF21 requires that an Internet mail entity be converted to
   canonical form prior to being transferred, as described in ndix G
   of RFC 1521 [5]. Section 3.6.1 of this document describes the forms
   allowed for subtypes of the "text" metype when transmitted over
   HTTP.

   RFC 1521 requires that content with a Content-Type of "text"
   represent lireaks as CRLF and forbids the use of CR or LF outside
   of line break sequences. HTTP allows CRLF, bare CR, and bare L
   indicate a line break within text content when a message is
   transmitted over HTTP.

   Where it is possible, oxy or gateway from HTTP to a strict RFC
   1521 environment should translate all line breaks within the text
   mediaes described in Section 3.6.1 of this document to the RFC
   1521 canonical form of CRLF. Note, however, that this may    complicated by the presence of a Content-Encoding and by the fact
   that HTTP allows the use of some character setsch do not use
   octets 13 and 10 to represent CR and LF, as is the case for some
   multi-byte character sets.



Berners-Lee, et al           Informational                     [Page 56]

RFC 1945                        HTTP/1.0                    May 1996


C.2  Conversion of Date Formats

   HTTP/1.0 uses a restricted set of date formats (Sen 3.3) to
   simplify the process of date comparison. Proxies and gateways from
   other protocols should ensure that Date header field present in a
   message conforms to one of the HTTP/1.0 formats and rewrite the date
   if necessary
C.3  Introduction of Content-Encoding

   RFC 1521 does not include any concept equivalent to HTTP/1.0's
   Content-ding header field. Since this acts as a modifier on the
   media type, proxies and gateways from HTTP to MIME-compliant protocols must either change the value of the Content-Type header
   field or decode the Entity-Body before forwarding message. (Some
   experimental applications of Content-Type for Internet mail have used
   a media-type parameter of nversions=<content-coding>" to perform
   an equivalent function as Content-Encoding. However, this parameter
   is nort of RFC 1521.)

C.4  No Content-Transfer-Encoding

   HTTP does not use the Content-Transfer-Encoding (CTE) field FC
   1521. Proxies and gateways from MIME-compliant protocols to HTTP must
   remove any non-identity CTE ("quoted-prble" or "base64") encoding
   prior to delivering the response message to an HTTP client.

   Proxies and gateways frTTP to MIME-compliant protocols are
   responsible for ensuring that the message is in the correct format
   and encodfor safe transport on that protocol, where "safe
   transport" is defined by the limitations of the protocol being used  Such a proxy or gateway should label the data with an appropriate
   Content-Transfer-Encoding if doing so will improhe likelihood of
   safe transport over the destination protocol.

C.5  HTTP Header Fields in Multipart Body-Parts
In RFC 1521, most header fields in multipart body-parts are generally
   ignored unless the field name begins with "Con-". In HTTP/1.0,
   multipart body-parts may contain any HTTP header fields which are
   significant to the meaning oft part.

D.  Additional Features

   This appendix documents protocol elements used by some existing HTTP
   implemtions, but not consistently and correctly across most
   HTTP/1.0 applications. Implementors should be aware of these
eatures, but cannot rely upon their presence in, or interoperability



Berners-Lee, et al           Informational                 [Page 57]

RFC 1945                        HTTP/1.0                        May 1996


   with, otheTP/1.0 applications.

D.1  Additional Request Methods

D.1.1 PUT

   The PUT method requests that the enclosed entbe stored under the
   supplied Request-URI. If the Request-URI refers to an already
   existing resource, the enclosetity should be considered as a
   modified version of the one residing on the origin server. If the
   Request-URI doet point to an existing resource, and that URI is
   capable of being defined as a new resource by the requesting user
gent, the origin server can create the resource with that URI.

   The fundamental difference between the POST and PUTuests is
   reflected in the different meaning of the Request-URI. The URI in a
   POST request identifies the resourcat will handle the enclosed
   entity as data to be processed. That resource may be a data-accepting
   process, a gat to some other protocol, or a separate entity that
   accepts annotations. In contrast, the URI in a PUT request identi
   the entity enclosed with the request -- the user agent knows what URI
   is intended and the server should not apphe request to some other
   resource.

D.1.2 DELETE

   The DELETE method requests that the origin server delete thsource
   identified by the Request-URI.

D.1.3 LINK

   The LINK method establishes one or more Link relationshipsween
   the existing resource identified by the Request-URI and other
   existing resources.

D.1.4 UNLINK

   TheINK method removes one or more Link relationships from the
   existing resource identified by the Request-URI.

D.2  tional Header Field Definitions

D.2.1 Accept

   The Accept request-header field can be used to indicate a list ofmedia ranges which are acceptable as a response to the request. The
   asterisk "*" character is used to group media tyinto ranges, with
   "*/*" indicating all media types and "type/*" indicating all subtypes



Berners-Lee, et al       Informational                     [Page 58]

RFC 1945                        HTTP/1.0                        May 


   of that type. The set of ranges given by the client should represent
   what types are acceptable given the cot of the request.

D.2.2 Accept-Charset

   The Accept-Charset request-header field can be used to indicate a
   lif preferred character sets other than the default US-ASCII and
   ISO-8859-1. This field allows clients capable of undending more
   comprehensive or special-purpose character sets to signal that
   capability to a server which is capabl representing documents in
   those character sets.

D.2.3 Accept-Encoding

   The Accept-Encoding request-header f is similar to Accept, but
   restricts the content-coding values which are acceptable in the
   response.

D.2.4 Ac-Language

   The Accept-Language request-header field is similar to Accept, but
   restricts the set of natural langs that are preferred as a
   response to the request.

D.2.5 Content-Language

   The Content-Language entity-headeeld describes the natural
   language(s) of the intended audience for the enclosed entity. Note
   that this may not buivalent to all the languages used within the
   entity.

D.2.6 Link

   The Link entity-header field provides a mefor describing a
   relationship between the entity and some other resource. An entity
   may include multiple Link va. Links at the metainformation level
   typically indicate relationships like hierarchical structure and
   navigationhs.

D.2.7 MIME-Version

   HTTP messages may include a single MIME-Version general-header field
   to indicate wharsion of the MIME protocol was used to construct
   the message. Use of the MIME-Version header field, as defined by RF  1521 [5], should indicate that the message is MIME-conformant.
   Unfortunately, some older HTTP/1.0 servers send it scriminately,
   and thus this field should be ignored.




Berners-Lee, et al           Informational                 [Page 59]

RFC 1945                        HTTP/1.0                        May 1996


D.2.8 Retry-After

   Retry-After response-header field can be used with a 503 (service
   unavailable) response to indicate how long the see is expected to
   be unavailable to the requesting client. The value of this field can
   be either an HTTP-date or nteger number of seconds (in decimal)
   after the time of the response.

D.2.9 Title

   The Title entity-header f indicates the title of the entity.

D.2.10 URI

   The URI entity-header field may contain some or all of the Unifo   Resource Identifiers (Section 3.2) by which the Request-URI resource
   can be identified. There is no guarantee thae resource can be
   accessed using the URI(s) specified.































Berners-Lee, et al           Informational                     [Page 60]
                                            T<<                                                                                                                     




Network Working Group                                     T. Berners-Lee
Request for Comments: 1945                                       MIT/LCS
Category: Informational                                      R. Fielding
                                                           UC Irvine
                                                          H. Frystyk
                                                                 MIT/LCS
                                                            May 1996


                Hypertext Transfer Protocol -- HTTP/1.0

Status of This Memo
 This memo provides information for the Internet community.  This memo
   does not specify an Internet standard of any .  Distribution of
   this memo is unlimited.

IESG Note:

   The IESG has concerns about this protocol, and expectis document
   to be replaced relatively soon by a standards track document.

Abstract

   The Hypertext Transfer Pcol (HTTP) is an application-level
   protocol with the lightness and speed necessary for distributed,
   collaborativypermedia information systems. It is a generic,
   stateless, object-oriented protocol which can be used for many tasks  such as name servers and distributed object management systems,
   through extension of its request methods (commands feature of
   HTTP is the typing of data representation, allowing systems to be
   built independently of the data betransferred.

   HTTP has been in use by the World-Wide Web global information
   initiative since 1990. This specifion reflects common usage of
   the protocol referred to as "HTTP/1.0".

Table of Contents

   1.  Introduction ..........................................  4
       1.1  Purpose ..............................................  4
        Terminology ..........................................  4
       1.3  Overall Operation ................................  6
       1.4  HTTP and MIME ........................................  8
   2.  Notational Conventions and Genericmmar ................  8
       2.1  Augmented BNF ........................................  8
       2.2  Basic Rules....................................... 10
   3.  Protocol Parameters ....................................... 12


ners-Lee, et al           Informational                      [Page 1]

RFC 1945                        HTTP/1.0                    May 1996


       3.1  HTTP Version ......................................... 12
       3.2  Uniform Rrce Identifiers ......................... 14
            3.2.1  General Syntax ................................ 14
        3.2.2  http URL ...................................... 15
       3.3  Date/Time Formats ................................ 15
       3.4  Character Sets ....................................... 17
       3.5  Content Codings .................................. 18
       3.6  Media Types .......................................... 19
            3.6.1  Cicalization and Text Defaults ............ 19
            3.6.2  Multipart Types ............................... 20
   3.7  Product Tokens ....................................... 20
   4.  HTTP Message .......................................... 21
       4.1  Message Types ........................................ 21
       4.2  Message Headers .................................. 22
       4.3  General Header Fields ................................ 23
   5.  Request ............................................... 23
       5.1  Request-Line ......................................... 23
        5.1.1  Method ........................................ 24
            5.1.2  Request-URI ............................... 24
       5.2  Request Header Fields ................................ 25
   6.  Response .............................................. 25
       6.1  Status-Line .......................................... 26
            6.1.1 tus Code and Reason Phrase ................. 26
       6.2  Response Header Fields ............................... 28
.  Entity .................................................... 28
       7.1  Entity Header Fields ............................. 29
       7.2  Entity Body .......................................... 29
            7.2.1  Type ...................................... 29
            7.2.2  Length ........................................ 30
   8.  Method Defions ........................................ 30
       8.1  GET .................................................. 31    8.2  HEAD ................................................. 31
       8.3  POST ............................................. 31
   9.  Status Code Definitions ................................... 32
       9.1  Informational 1xx ................................ 32
       9.2  Successful 2xx ....................................... 32
       9.3  Rediion 3xx ...................................... 34
       9.4  Client Error 4xx ..................................... 35     9.5  Server Error 5xx ..................................... 37
   10. Header Field Definitions .............................. 37
       10.1  Allow ............................................... 38
       10.2  Authorization ................................... 38
       10.3  Content-Encoding .................................... 39
       10.4  Cot-Length ...................................... 39
       10.5  Content-Type ........................................ 4      10.6  Date ................................................ 40
       10.7  Expires ......................................... 41
       10.8  From ................................................ 42



Berners-Lee, et al        nformational                      [Page 2]

RFC 1945                        HTTP/1.0                        May 1996
       10.9  If-Modified-Since ................................... 42
       10.10 Last-Modified ................................... 43
       10.11 Location ............................................ 44
       10.12 Pragma .......................................... 44
       10.13 Referer ............................................. 44
       10.14ver .............................................. 45
       10.15 User-Agent .........................................
       10.16 WWW-Authenticate .................................... 46
   11. Access Authentication ................................. 47
       11.1  Basic Authentication Scheme ......................... 48
   12. Security Consideration................................. 49
       12.1  Authentication of Clients ........................... 49
       12.2fe Methods ........................................ 49
       12.3  Abuse of Server Log Information ...................0
       12.4  Transfer of Sensitive Information ................... 50
       12.5  Attacks Based On File and Path Na................ 51
   13. Acknowledgments ........................................... 51
   14. References ............................................ 52
   15. Authors' Addresses ........................................ 54
   Appendi   Internet Media Type message/http ................ 55
   Appendix B.   Tolerant Applications ........................55
   Appendix C.   Relationship to MIME ............................ 56
       C.1  Conversion to Canonical Form ..................... 56
       C.2  Conversion of Date Formats ........................... 57
       C.3  Introduction oftent-Encoding ..................... 57
       C.4  No Content-Transfer-Encoding ......................... 57
       C.TTP Header Fields in Multipart Body-Parts ........... 57
   Appendix D.   Additional Features ......................... 57
       D.1  Additional Request Methods ........................... 58
            D.1.1  PUT ....................................... 58
            D.1.2  DELETE ........................................ 58
            D.1.3  LINK ...................................... 58
            D.1.4  UNLINK ........................................ 58
       DAdditional Header Field Definitions .................. 58
            D.2.1  Accept .................................... 58
            D.2.2  Accept-Charset ................................ 59
            D.2.3  Accept-Encoding ........................... 59
            D.2.4  Accept-Language ............................... 59
            D.2.5  Contennguage .............................. 59
            D.2.6  Link .......................................... 59
        D.2.7  MIME-Version .................................. 59
            D.2.8  Retry-After ............................... 60
            D.2.9  Title ......................................... 60
            D.2.10 URI ....................................... 60







Berners-Lee, et al           Informational                      [Page 3]

RFC                         HTTP/1.0                        May 1996


1.  Introduction

1.1  Purpose

   The Hyperteransfer Protocol (HTTP) is an application-level
   protocol with the lightness and speed necessary for distributed,
  laborative, hypermedia information systems. HTTP has been in use
   by the World-Wide Web global information initiativece 1990. This
   specification reflects common usage of the protocol referred too as
   "HTTP/1.0". This specificationcribes the features that seem to be
   consistently implemented in most HTTP/1.0 clients and servers. The
   specifica is split into two sections. Those features of HTTP for
   which implementations are usually consistent are described ie
   main body of this document. Those features which have few or
   inconsistent implementations are listed in Append.

   Practical information systems require more functionality than simple
   retrieval, including search, front-end te, and annotation. HTTP
   allows an open-ended set of methods to be used to indicate the
   purpose of a request. Itlds on the discipline of reference
   provided by the Uniform Resource Identifier (URI) [2], as a location
   (URL) [4 name (URN) [16], for indicating the resource on which a
   method is to be applied. Messages are passed in a format sir to
   that used by Internet Mail [7] and the Multipurpose Internet Mail
   Extensions (MIME) [5].

   HTTP is alsod as a generic protocol for communication between
   user agents and proxies/gateways to other Internet protocols, such
   SMTP [12], NNTP [11], FTP [14], Gopher [1], and WAIS [8], allowing
   basic hypermedia access to resources availablom diverse
   applications and simplifying the implementation of user agents.

1.2  Terminology

   This specificatuses a number of terms to refer to the roles
   played by participants in, and objects of, the HTTP communication.

 nnection

       A transport layer virtual circuit established between two
       application programs for the purpos communication.

   message

       The basic unit of HTTP communication, consisting of a structured
       sequenc octets matching the syntax defined in Section 4 and
       transmitted via the connection.




Berners-Lee, et al       Informational                      [Page 4]

RFC 1945                        HTTP/1.0                        M996


   request

       An HTTP request message (as defined in Section 5).

   response

       An HTTP responessage (as defined in Section 6).

   resource

       A network data object or service which can be identified by a     URI (Section 3.2).

   entity

       A particular representation or rendition of a data resource, or
       r from a service resource, that may be enclosed within a
       request or response message. An entity consists of
    etainformation in the form of entity headers and content in the
       form of an entity body.

   client

       Aplication program that establishes connections for the
       purpose of sending requests.

   user agent

       Tlient which initiates a request. These are often browsers,
       editors, spiders (web-traversing robots), or other ener
       tools.

   server

       An application program that accepts connections in order to
       service reqs by sending back responses.

   origin server

       The server on which a given resource resides or is to be crea

   proxy

       An intermediary program which acts as both a server and a client
       for the purpose of makinquests on behalf of other clients.
       Requests are serviced internally or by passing them, with
       possible tration, on to other servers. A proxy must
       interpret and, if necessary, rewrite a request message before



Bes-Lee, et al           Informational                      [Page 5]

RFC 1945                        HTTP/1.0                    May 1996


       forwarding it. Proxies are often used as client-side portals
       through network firls and as helper applications for
       handling requests via protocols not implemented by the user
       agent.

ateway

       A server which acts as an intermediary for some other server.
       Unlike a proxy, a gateway receivequests as if it were the
       origin server for the requested resource; the requesting client
       may not be awarat it is communicating with a gateway.
       Gateways are often used as server-side portals through network
       fills and as protocol translators for access to resources
       stored on non-HTTP systems.

   tunnel

       A tunis an intermediary program which is acting as a blind
       relay between two connections. Once active, a tunnel is no      considered a party to the HTTP communication, though the tunnel
       may have been initiated by an HTTP requeste tunnel ceases to
       exist when both ends of the relayed connections are closed.
       Tunnels are used when a pl is necessary and the intermediary
       cannot, or should not, interpret the relayed communication.

   cache

   A program's local store of response messages and the subsystem
       that controls its message storage, retrieval, aeletion. A
       cache stores cachable responses in order to reduce the response
       time and network bandwidth coption on future, equivalent
       requests. Any client or server may include a cache, though a
       cache cannot bed by a server while it is acting as a tunnel.

   Any given program may be capable of being both a client and a server  our use of these terms refers only to the role being performed by the
   program for a particular connection, rather  to the program's
   capabilities in general. Likewise, any server may act as an origin
   server, proxy, gateway, or el, switching behavior based on the
   nature of each request.

1.3  Overall Operation

   The HTTP protocol is basn a request/response paradigm. A client
   establishes a connection with a server and sends a request to the
   serverthe form of a request method, URI, and protocol version,
   followed by a MIME-like message containing request modifierlient
   information, and possible body content. The server responds with a



Berners-Lee, et al           Informaal                      [Page 6]

RFC 1945                        HTTP/1.0                        May 1996


   st line, including the message's protocol version and a success
   or error code, followed by a MIME-like message containserver
   information, entity metainformation, and possible body content.

   Most HTTP communication is initiated byser agent and consists of
   a request to be applied to a resource on some origin server. In the
   simplest case, thiy be accomplished via a single connection (v)
   between the user agent (UA) and the origin server (O).

          ret chain ------------------------>
       UA -------------------v------------------- O
          <---------------------esponse chain

   A more complicated situation occurs when one or more intermediaries
   are present in the request/rnse chain. There are three common
   forms of intermediary: proxy, gateway, and tunnel. A proxy is a
   forwarding agereceiving requests for a URI in its absolute form,
   rewriting all or parts of the message, and forwarding the reforma
   request toward the server identified by the URI. A gateway is a
   receiving agent, acting as a layer above some o server(s) and, if
   necessary, translating the requests to the underlying server's
   protocol. A tunnel acts as a r point between two connections
   without changing the messages; tunnels are used when the
   communication needs to pthrough an intermediary (such as a
   firewall) even when the intermediary cannot understand the contents
   of the mees.

          request chain -------------------------------------->
       UA -----v----- A -----v----- B -----v---------v----- O
          <------------------------------------- response chain

   The figure above shows three intermries (A, B, and C) between the
   user agent and origin server. A request or response message that
   travels the wholain must pass through four separate connections.
   This distinction is important because some HTTP communication optio   may apply only to the connection with the nearest, non-tunnel
   neighbor, only to the end-points of the chain, or tl connections
   along the chain. Although the diagram is linear, each participant may
   be engaged in multiple, simueous communications. For example, B
   may be receiving requests from many clients other than A, and/or
   forwarding ests to servers other than C, at the same time that it
   is handling A's request.

   Any party to the communicationch is not acting as a tunnel may
   employ an internal cache for handling requests. The effect of a cache
   is that tequest/response chain is shortened if one of the
   participants along the chain has a cached response applicable to th   request. The following illustrates the resulting chain if B has a



Berners-Lee, et al           Informational                  [Page 7]

RFC 1945                        HTTP/1.0                        May 1996


   cached cop an earlier response from O (via C) for a request which
   has not been cached by UA or A.

          request chain ------>
       UA -----v----- A -----v----- B - - - - - - C - - - - - - O
          <--------- response chain

   Not responses are cachable, and some requests may contain
   modifiers which place special requirements on cache behavior.e
   HTTP/1.0 applications use heuristics to describe what is or is not a
   "cachable" response, but these rules are standardized.

   On the Internet, HTTP communication generally takes place over TCP/IP
   connections. The default pis TCP 80 [15], but other ports can be
   used. This does not preclude HTTP from being implemented on top of
   any otprotocol on the Internet, or on other networks. HTTP only
   presumes a reliable transport; any protocol that provides 
   guarantees can be used, and the mapping of the HTTP/1.0 request and
   response structures onto the transport datats of the protocol in
   question is outside the scope of this specification.

   Except for experimental applicationurrent practice requires that
   the connection be established by the client prior to each request and
   closed by thrver after sending the response. Both clients and
   servers should be aware that either party may close the connection prematurely, due to user action, automated time-out, or program
   failure, and should handle such closing in a predice fashion. In
   any case, the closing of the connection by either or both parties
   always terminates the current ret, regardless of its status.

1.4  HTTP and MIME

   HTTP/1.0 uses many of the constructs defined for MIME, as definn
   RFC 1521 [5]. Appendix C describes the ways in which the context of
   HTTP allows for different use of Internet a Types than is
   typically found in Internet mail, and gives the rationale for those
   differences.

2.  Notationonventions and Generic Grammar

2.1  Augmented BNF

   All of the mechanisms specified in this document are describe
   both prose and an augmented Backus-Naur Form (BNF) similar to that
   used by RFC 822 [7]. Implementors will need e familiar with the
   notation in order to understand this specification. The augmented BNF
   includes the followingstructs:




Berners-Lee, et al           Informational                      [Page 8]

RFC 1945                    HTTP/1.0                        May 1996


   name = definition

       The name of a rule is simply the name it (without any
       enclosing "<" and ">") and is separated from its definition by
       the equal character "=". Whpace is only significant in that
       indentation of continuation lines is used to indicate a rule
       definitiont spans more than one line. Certain basic rules
       are in uppercase, such as SP, LWS, HT, CRLF, DIGIT, ALPHA, etc.    Angle brackets are used within definitions whenever their
       presence will facilitate discerning the use of rulmes.

   "literal"

       Quotation marks surround literal text. Unless stated otherwise,
       the text is case-nsitive.

   rule1 | rule2

       Elements separated by a bar ("I") are alternatives,
       e.g., "yes | no" willept yes or no.

   (rule1 rule2)

       Elements enclosed in parentheses are treated as a single
       element. T "(elem (foo | bar) elem)" allows the token
       sequences "elem foo elem" and "elem bar elem".

   *rule

       character "*" preceding an element indicates repetition. The
       full form is "<n>*<m>element" indicating at least and at
       most <m> occurrences of element. Default values are 0 and
       infinity so that "*(element)" allows anmber, including zero;
       "1*element" requires at least one; and "1*2element" allows one
       or two.

   [rule
       Square brackets enclose optional elements; "[foo bar]" is
       equivalent to "*1(foo bar)".

   N rule

   Specific repetition: "<n>(element)" is equivalent to
       "<n>*<n>(element)"; that is, exactly <n> occurrences of
   (element). Thus 2DIGIT is a 2-digit number, and 3ALPHA is a
       string of three alphabetic characters.




Brs-Lee, et al           Informational                      [Page 9]

RFC 1945                        HTTP/1.0                    May 1996


   #rule

       A construct "#" is defined, similar to "*", for defining lists
       of ents. The full form is "<n>#<m>element" indicating at
       least <n> and at most <m> elements, each separated by one o      more commas (",") and optional linear whitespace (LWS). This
       makes the usual form of lists very easy; a ruuch as
       "( *LWS element *( *LWS "," *LWS element ))" can be shown as
       "1#element". Wherever this constructused, null elements are
       allowed, but do not contribute to the count of elements present.
       That is, "(elem, , (element)" is permitted, but counts as
       only two elements. Therefore, where at least one element is
       rred, at least one non-null element must be present. Default
       values are 0 and infinity so that "#(element)" allowy
       number, including zero; "1#element" requires at least one; and
       "1#2element" allows one or two.

   ;ment

       A semi-colon, set off some distance to the right of rule text,
       starts a comment that continues to end of line. This is a
       simple way of including useful notes in parallel with the
       specifications.

   ied *LWS

       The grammar described by this specification is word-based.
       Except where noted otherwise, linehitespace (LWS) can be
       included between any two adjacent words (token or
       quoted-string), and between adjt tokens and delimiters
       (tspecials), without changing the interpretation of a field. At
       least one delimi(tspecials) must exist between any two
       tokens, since they would otherwise be interpreted as a single
       tokHowever, applications should attempt to follow "common
       form" when generating HTTP constructs, since there exist 
       implementations that fail to accept anything beyond the common
       forms.

2.2  Basic Rules

   The folng rules are used throughout this specification to
   describe basic parsing constructs. The US-ASCII coded character s   is defined by [17].

       OCTET          = <any 8-bit sequence of data>
       CHAR           = <any US-ASCII chter (octets 0 - 127)>
       UPALPHA        = <any US-ASCII uppercase letter "A".."Z">
       LOALPHA        = <any USII lowercase letter "a".."z">



Berners-Lee, et al           Informational                     [Page 10]

RFC 19                      HTTP/1.0                        May 1996


       ALPHA          = UPALPHA | LOALPHA
       DI         = <any US-ASCII digit "0".."9">
       CTL            = <any US-ASCII control character
                     octets 0 - 31) and DEL (127)>
       CR             = <US-ASCII CR, carriage return (13)>
       LF             = <US-I LF, linefeed (10)>
       SP             = <US-ASCII SP, space (32)>
       HT             = <US-ASCII HT, horizontab (9)>
       <">            = <US-ASCII double-quote mark (34)>

   HTTP/1.0 defines the octet sequence CR LF as the-of-line marker
   for all protocol elements except the Entity-Body (see Appendix B for
   tolerant applications). The-of-line marker within an Entity-Body
   is defined by its associated media type, as described in Section 3.6.

     LF           = CR LF

   HTTP/1.0 headers may be folded onto multiple lines if each
   continuation line begins with ace or horizontal tab. All linear
   whitespace, including folding, has the same semantics as SP.

       LWS        = [CRLF] 1*( SP | HT )

   However, folding of header lines is not expected by some
   applications, and should not bnerated by HTTP/1.0 applications.

   The TEXT rule is only used for descriptive field contents and values
   that art intended to be interpreted by the message parser. Words
   of *TEXT may contain octets from character sets other thanASCII.

       TEXT           = <any OCTET except CTLs,
                        but including LWS>

   Recipients oader field TEXT containing octets outside the US-
   ASCII character set may assume that they represent ISO-8859-1
   acters.

   Hexadecimal numeric characters are used in several protocol elements.

       HEX            = "A" | "B"C" | "D" | "E" | "F"
                      | "a" | "b" | "c" | "d" | "e" | "f" | DIGIT

   Many HTTP/1.0 header fieldues consist of words separated by LWS
   or special characters. These special characters must be in a quoted
   stringbe used within a parameter value.

       word           = token | quoted-string




Berners-Lee, et al          ormational                     [Page 11]

RFC 1945                        HTTP/1.0                        May 1996
      token          = 1*<any CHAR except CTLs or tspecials>

       tspecials      = "(" | ")" | "<" | ">" | "@"
                  | "," | ";" | ":" | "\" | <">
                      | "/" | "[" | "]" | "?" | "="
                     {" | "}" | SP | HT

   Comments may be included in some HTTP header fields by surrounding
   the comment text with paheses. Comments are only allowed in
   fields containing "comment" as part of their field value definition.
   In all r fields, parentheses are considered part of the field
   value.

       comment        = "(" *( ctext | comment ) ")      ctext          = <any TEXT excluding "(" and ")">

   A string of text is parsed as a single word if it is quoteing
   double-quote marks.

       quoted-string  = ( <"> *(qdtext) <"> )

       qdtext         = <any CHAR except and CTLs,
                        but including LWS>

   Single-character quoting using the backslash ("\") characte not
   permitted in HTTP/1.0.

3.  Protocol Parameters

3.1  HTTP Version

   HTTP uses a "<major>.<minor>" numbg scheme to indicate versions
   of the protocol. The protocol versioning policy is intended to allow
   the sender toicate the format of a message and its capacity for
   understanding further HTTP communication, rather than the feature  obtained via that communication. No change is made to the version
   number for the addition of message components whdo not affect
   communication behavior or which only add to extensible field values.
   The <minor> number is increme when the changes made to the
   protocol add features which do not change the general message parsing
   algorithm, bhich may add to the message semantics and imply
   additional capabilities of the sender. The <major> number is
   incnted when the format of a message within the protocol is
   changed.

   The version of an HTTP message is indicated n HTTP-Version field
   in the first line of the message. If the protocol version is not
   specified, the recipient massume that the message is in the



Berners-Lee, et al           Informational                     [Page 12]

RF45                        HTTP/1.0                        May 1996


   simple HTTP/0.9 format.

       HTTP-Versio= "HTTP" "/" 1*DIGIT "." 1*DIGIT

   Note that the major and minor numbers should be treated as separate
   integers that each may be incremented higher than a single digit.
   Thus, HTTP/2.4 is a lower version than HTTP/2.13, which in  is
   lower than HTTP/12.3. Leading zeros should be ignored by recipients
   and never generated by senders.

   Thocument defines both the 0.9 and 1.0 versions of the HTTP
   protocol. Applications sending Full-Request or Full-Respon   messages, as defined by this specification, must include an HTTP-
   Version of "HTTP/1.0".

   HTTP/1.0 servers m

      o recognize the format of the Request-Line for HTTP/0.9 and
        HTTP/1.0 requests;

      o understand valid request in the format of HTTP/0.9 or
        HTTP/1.0;

      o respond appropriately with a message in the samotocol
        version used by the client.

   HTTP/1.0 clients must:

      o recognize the format of the Status-Lfor HTTP/1.0 responses;

      o understand any valid response in the format of HTTP/0.9 or
        HTTP/1.0.

   P and gateway applications must be careful in forwarding requests
   that are received in a format different than that oe
   application's native HTTP version. Since the protocol version
   indicates the protocol capability of the sender,roxy/gateway must
   never send a message with a version indicator which is greater than
   its native version; if a hr version request is received, the
   proxy/gateway must either downgrade the request version or respond
   with an er Requests with a version lower than that of the
   application's native format may be upgraded before being forwarded;the proxy/gateway's response to that request must follow the server
   requirements listed above.







Bernere, et al           Informational                     [Page 13]

RFC 1945                        HTTP/1.0                    May 1996


3.2  Uniform Resource Identifiers

   URIs have been known by many names: WWW addresses, Universacument
   Identifiers, Universal Resource Identifiers [2], and finally the
   combination of Uniform Resource LocatorsL) [4] and Names (URN)
   [16]. As far as HTTP is concerned, Uniform Resource Identifiers are
   simply formatted striwhich identify--via name, location, or any
   other characteristic--a network resource.

3.2.1 General Syntax

   Uin HTTP can be represented in absolute form or relative to some
   known base URI [9], depending upon the context of thuse. The two
   forms are differentiated by the fact that absolute URIs always begin
   with a scheme name followed byolon.

       URI            = ( absoluteURI | relativeURI ) [ "#" fragment ]

       absoluteURI    = scheme ":" *(ar | reserved )

       relativeURI    = net_path | abs_path | rel_path

       net_path       = "//" net_loc [ abs_ ]
       abs_path       = "/" rel_path
       rel_path       = [ path ] [ ";" params ] [ "?" query ]

       path       = fsegment *( "/" segment )
       fsegment       = 1*pchar
       segment        = *pchar

       params       param *( ";" param )
       param          = *( pchar | "/" )

       scheme         = 1*( ALPHA | DIGIT | "+" | "-"." )
       net_loc        = *( pchar | ";" | "?" )
       query          = *( uchar | reserved )
       fragment     *( uchar | reserved )

       pchar          = uchar | ":" | "@" | "&" | "=" | "+"
       uchar          = unreserveescape
       unreserved     = ALPHA | DIGIT | safe | extra | national

       escape         = "%" HEX HEX
       rved       = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+"
       extra          = "!" | "*" | "'" | "(" | ")" | ","
   safe           = "$" | "-" | "_" | "."
       unsafe         = CTL | SP | <"> | "#" | "%" | "<" | ">"
       national   = <any OCTET excluding ALPHA, DIGIT,



Berners-Lee, et al           Informational                     [Page 14]RFC 1945                        HTTP/1.0                        May 1996


                        reserved, extra, s and unsafe>

   For definitive information on URL syntax and semantics, see RFC 1738
   [4] and RFC 1808 [9]. The BNove includes national characters not
   allowed in valid URLs as specified by RFC 1738, since HTTP servers
   are not ricted in the set of unreserved characters allowed to
   represent the rel_path part of addresses, and HTTP proxies may receive requests for URIs not defined by RFC 1738.

3.2.2 http URL

   The "http" scheme is used to locate network urces via the HTTP
   protocol. This section defines the scheme-specific syntax and
   semantics for http URLs.

   http_URL       = "http:" "//" host [ ":" port ] [ abs_path ]

       host           = <A legal Internet host domain na                         or IP address (in dotted-decimal form),
                         as defined by Section 2.1 of 1123>

       port           = *DIGIT

   If the port is empty or not given, port 80 is assumed. The semantics
   ahat the identified resource is located at the server listening
   for TCP connections on that port of that host, and thquest-URI
   for the resource is abs_path. If the abs_path is not present in the
   URL, it must be given as "/" when  as a Request-URI (Section
   5.1.2).

      Note: Although the HTTP protocol is independent of the transport
      r protocol, the http URL only identifies resources by their
      TCP location, and thus non-TCP resources must be idened by
      some other URI scheme.

   The canonical form for "http" URLs is obtained by converting any
   UPALPHA ccters in host to their LOALPHA equivalent (hostnames are
   case-insensitive), eliding the [ ":" port ] if the port is and
   replacing an empty abs_path with "/".

3.3  Date/Time Formats

   HTTP/1.0 applications have historically ald three different
   formats for the representation of date/time stamps:

       Sun, 06 Nov 1994 08:49:37 GMT    ; R22, updated by RFC 1123
       Sunday, 06-Nov-94 08:49:37 GMT   ; RFC 850, obsoleted by RFC 1036
       Sun Nov  6 08:7 1994         ; ANSI C's asctime() format



Berners-Lee, et al           Informational                     [Page 1
RFC 1945                        HTTP/1.0                        May 1996


   The first format is preferred as an rnet standard and represents
   a fixed-length subset of that defined by RFC 1123 [6] (an update to
   RFC 822 [7]). Tecond format is in common use, but is based on the
   obsolete RFC 850 [10] date format and lacks a four-digit year.
 TP/1.0 clients and servers that parse the date value should accept
   all three formats, though they must never generate third
   (asctime) format.

      Note: Recipients of date values are encouraged to be robust in
      accepting dvalues that may have been generated by non-HTTP
      applications, as is sometimes the case when retrieving or posting    messages via proxies/gateways to SMTP or NNTP.

   All HTTP/1.0 date/time stamps must be represented in Universal 
   (UT), also known as Greenwich Mean Time (GMT), without exception.
   This is indicated in the first two formats by inclusion of "GMT"
   as the three-letter abbreviation for time zone, and should be assumed
   when reading the asctiormat.

       HTTP-date      = rfc1123-date | rfc850-date | asctime-date

       rfc1123-date   = wkday "," SP date time SP "GMT"
       rfc850-date    = weekday "," SP date2 SP time SP "GMT"
       asctime-date   = wkday SP date3 SPe SP 4DIGIT

       date1          = 2DIGIT SP month SP 4DIGIT
                        ; day month year (e.g., 02 Jun2)
       date2          = 2DIGIT "-" month "-" 2DIGIT
                        ; day-month-year (e.g., 02-Jun-82)
   date3          = month SP ( 2DIGIT | ( SP 1DIGIT ))
                        ; month day (e.g., Jun  2)

       time       = 2DIGIT ":" 2DIGIT ":" 2DIGIT
                        ; 00:00:00 - 23:59:59

       wkday          = "Mon" | "T| "Wed"
                      | "Thu" | "Fri" | "Sat" | "Sun"

       weekday        = "Monday" | "Tuesday" | "Wednes
                      | "Thursday" | "Friday" | "Saturday" | "Sunday"

       month          = "Jan" | "Feb" | "Mar"Apr"
                      | "May" | "Jun" | "Jul" | "Aug"
                      | "Sep" | "Oct" | "Nov" | "Dec"

   Note: HTTP requirements for the date/time stamp format apply
       only to their usage within the protocol stream. Cls and
       servers are not required to use these formats for user



Berners-Lee, et al           Informational                 [Page 16]

RFC 1945                        HTTP/1.0                        May 1996


       presenon, request logging, etc.

3.4  Character Sets

   HTTP uses the same definition of the term "character set" as that described for MIME:

      The term "character set" is used in this document to refer to a
      method used with on more tables to convert a sequence of
      octets into a sequence of characters. Note that unconditional
      conver in the other direction is not required, in that not all
      characters may be available in a given character set and      character set may provide more than one sequence of octets to
      represent a particular character. This defini is intended to
      allow various kinds of character encodings, from simple single-
      table mappings such as US-I to complex table switching methods
      such as those that use ISO 2022's techniques. However, the
      definitionociated with a MIME character set name must fully
      specify the mapping to be performed from octets to characters.       particular, use of external profiling information to determine the
      exact mapping is not permitted.

     e: This use of the term "character set" is more commonly
      referred to as a "character encoding." However, since HTnd
      MIME share the same registry, it is important that the terminology
      also be shared.

   HTTP characters are identified by case-insensitive tokens. The
   complete set of tokens are defined by the IANA Character Set regist   [15]. However, because that registry does not define a single,
   consistent token for each character set, we definee the preferred
   names for those character sets most likely to be used with HTTP
   entities. These character sets ide those registered by RFC 1521
   [5] -- the US-ASCII [17] and ISO-8859 [18] character sets -- and
   other names specally recommended for use within MIME charset
   parameters.

     charset = "US-ASCII"
             | "ISO-8859-1" SO-8859-2" | "ISO-8859-3"
             | "ISO-8859-4" | "ISO-8859-5" | "ISO-8859-6"
             | "ISO-8859-7" | "ISO9-8" | "ISO-8859-9"
             | "ISO-2022-JP" | "ISO-2022-JP-2" | "ISO-2022-KR"
             | "UNICODE-1-1" | "UNI-1-1-UTF-7" | "UNICODE-1-1-UTF-8"
             | token

   Although HTTP allows an arbitrary token to be used as a cht
   value, any token that has a predefined value within the IANA
   Character Set registry [15] must represent the chter set defined



Berners-Lee, et al           Informational                     [Page 17]

RFC 1945                    HTTP/1.0                        May 1996


   by that registry. Applications should limit their use of charac
   sets to those defined by the IANA registry.

   The character set of an entity body should be labelled as the lowe   common denominator of the character codes used within that body, with
   the exception that no label is preferred ovhe labels US-ASCII or
   ISO-8859-1.

3.5  Content Codings

   Content coding values are used to indicate an encodiransformation
   that has been applied to a resource. Content codings are primarily
   used to allow a document to be ressed or encrypted without losing
   the identity of its underlying media type. Typically, the resource is
   stored his encoding and only decoded before rendering or
   analogous usage.

       content-coding = "x-gzip" | "x-compresstoken

       Note: For future compatibility, HTTP/1.0 applications should
       consider "gzip" and "compress" to buivalent to "x-gzip"
       and "x-compress", respectively.

   All content-coding values are case-insensitive. HTTP/uses
   content-coding values in the Content-Encoding (Section 10.3) header
   field. Although the value describes thetent-coding, what is more
   important is that it indicates what decoding mechanism will be
   required to remove the ding. Note that a single program may be
   capable of decoding multiple content-coding formats. Two values are
   defiby this specification:

   x-gzip
       An encoding format produced by the file compression program
       "gzip" (zip) developed by Jean-loup Gailly. This format is
       typically a Lempel-Ziv coding (LZ77) with a 32 bit CRC.

  ompress
       The encoding format produced by the file compression program
       "compress". This format is an adaptLempel-Ziv-Welch coding
       (LZW).

       Note: Use of program names for the identification of
       encoding fts is not desirable and should be discouraged
       for future encodings. Their use here is representative of
       orical practice, not good design.






Berners-Lee, et al           Informational                     [Page 18]RFC 1945                        HTTP/1.0                        May 1996


3.6  Media Types

   HTTP uses Internet a Types [13] in the Content-Type header field
   (Section 10.5) in order to provide open and extensible data typing.
    media-type     = type "/" subtype *( ";" parameter )
       type           = token
       subtype        = token
 Parameters may follow the type/subtype in the form of attribute/value
   pairs.

       parameter      = attribute "alue
       attribute      = token
       value          = token | quoted-string

   The type, subtype, and parametetribute names are case-
   insensitive. Parameter values may or may not be case-sensitive,
   depending on the semantif the parameter name. LWS must not be
   generated between the type and subtype, nor between an attribute and
   its v. Upon receipt of a media type with an unrecognized
   parameter, a user agent should treat the media type as if the
 recognized parameter and its value were not present.

   Some older HTTP applications do not recognize media type parars.
   HTTP/1.0 applications should only use media type parameters when they
   are necessary to define the content ofessage.

   Media-type values are registered with the Internet Assigned Number
   Authority (IANA [15]). The media tyegistration process is
   outlined in RFC 1590 [13]. Use of non-registered media types is
   discouraged.

3.6.1 Canalization and Text Defaults

   Internet media types are registered with a canonical form. In
   general, an Entity-Btransferred via HTTP must be represented in
   the appropriate canonical form prior to its transmission. If the body
 s been encoded with a Content-Encoding, the underlying data should
   be in canonical form prior to being encoded.

 dia subtypes of the "text" type use CRLF as the text line break
   when in canonical form. However, HTTP allows the trart of text
   media with plain CR or LF alone representing a line break when used
   consistently within the Entity-BoHTTP applications must accept
   CRLF, bare CR, and bare LF as being representative of a line break in
   text media rved via HTTP.




Berners-Lee, et al           Informational                     [Page 19]

RFC 1945                    HTTP/1.0                        May 1996


   In addition, if the text media is represented in a character seat
   does not use octets 13 and 10 for CR and LF respectively, as is the
   case for some multi-byte character sets,  allows the use of
   whatever octet sequences are defined by that character set to
   represent the equivalent of CR LF for line breaks. This
   flexibility regarding line breaks applies only to text media in the
   Entity-Body; a bareor LF should not be substituted for CRLF
   within any of the HTTP control structures (such as header fields and
   muart boundaries).

   The "charset" parameter is used with some media types to define the
   character set (Section 3.f the data. When no explicit charset
   parameter is provided by the sender, media subtypes of the "text"
   type are ned to have a default charset value of "ISO-8859-1" when
   received via HTTP. Data in character sets other than "ISO-81" or
   its subsets must be labelled with an appropriate charset value in
   order to be consistently interpreted by recipient.

      Note: Many current HTTP servers provide data using charsets other
      than "ISO-8859-1" without pr labelling. This situation reduces
      interoperability and is not recommended. To compensate for this,
      some  user agents provide a configuration option to allow the
      user to change the default interpretation of the media t
      character set when no charset parameter is given.

3.6.2 Multipart Types

   MIME provides for a number of "mpart" types -- encapsulations of
   several entities within a single message's Entity-Body. The multipart
   types regred by IANA [15] do not have any special meaning for
   HTTP/1.0, though user agents may need to understand each type i  order to correctly interpret the purpose of each body-part. An HTTP
   user agent should follow the same or similar bior as a MIME user
   agent does upon receipt of a multipart type. HTTP servers should not
   assume that all HTTP cli are prepared to handle multipart types.

   All multipart types share a common syntax and must include a boundary
  ameter as part of the media type value. The message body is itself
   a protocol element and must therefore use only CRo represent line
   breaks between body-parts. Multipart body-parts may contain HTTP
   header fields which are signift to the meaning of that part.

3.7  Product Tokens

   Product tokens are used to allow communicating applications    identify themselves via a simple product token, with an optional
   slash and version designator. Most fields using uct tokens also
   allow subproducts which form a significant part of the application to



Berners-Lee, et al       Informational                     [Page 20]

RFC 1945                        HTTP/1.0                        May 19

   be listed, separated by whitespace. By convention, the products are
   listed in order of their significance forntifying the
   application.

       product         = token ["/" product-version]
       product-version = token
Examples:

       User-Agent: CERN-LineMode/2.15 libwww/2.17b3

       Server: Apache/0.8.4

   Product tokens shobe short and to the point -- use of them for
   advertizing or other non-essential information is explicitly
   forbid Although any token character may appear in a product-
   version, this token should only be used for a version identif
   (i.e., successive versions of the same product should only differ in
   the product-version portion of the product e).

4.  HTTP Message

4.1  Message Types

   HTTP messages consist of requests from client to server and response  from server to client.

       HTTP-message   = Simple-Request           ; HTTP/0.9 messages
                      mple-Response
                      | Full-Request             ; HTTP/1.0 messages
                      | Full-Respon
   Full-Request and Full-Response use the generic message format of RFC
   822 [7] for transferring entities. Both mees may include optional
   header fields (also known as "headers") and an entity body. The
   entity body is separatedm the headers by a null line (i.e., a
   line with nothing preceding the CRLF).

       Full-Request   = Request-Line         ; Section 5.1
                        *( General-Header        ; Section 4.3
                         | Requeeader        ; Section 5.2
                         | Entity-Header )       ; Section 7.1
                        CRLF                      [ Entity-Body ]          ; Section 7.2

       Full-Response  = Status-Line              ; Secti.1
                        *( General-Header        ; Section 4.3
                         | Response-Header       ; Son 6.2



Berners-Lee, et al           Informational                     [Page 21]

RFC 1945                     TTP/1.0                        May 1996


                         | Entity-Header )       ; Section 7.1
                    CRLF
                        [ Entity-Body ]          ; Section 7.2

   Simple-Request and Simple-Response dt allow the use of any header
   information and are limited to a single request method (GET).

       Simple-Request"GET" SP Request-URI CRLF

       Simple-Response = [ Entity-Body ]

   Use of the Simple-Request format is discourabecause it prevents
   the server from identifying the media type of the returned entity.

4.2  Message Headers

  P header fields, which include General-Header (Section 4.3),
   Request-Header (Section 5.2), Response-Header (Section , and
   Entity-Header (Section 7.1) fields, follow the same generic format as
   that given in Section 3.1 of RFC 822. Each header field consists
   of a name followed immediately by a colon (":"), a single space (SP)
   character, and field value. Field names are case-insensitive.
   Header fields can be extended over multiple lines by preceding eachextra line with at least one SP or HT, though this is not
   recommended.

       HTTP-header    = field-name ":" [ f-value ] CRLF

       field-name     = token
       field-value    = *( field-content | LWS )

       field-content<the OCTETs making up the field-value
                        and consisting of either *TEXT or combinations
                    of token, tspecials, and quoted-string>

   The order in which header fields are received is not significan   However, it is "good practice" to send General-Header fields first,
   followed by Request-Header or Response-Headerlds prior to the
   Entity-Header fields.

   Multiple HTTP-header fields with the same field-name may be present
  a message if and only if the entire field-value for that header
   field is defined as a comma-separated list [i.e., #(es)]. It must
   be possible to combine the multiple header fields into one "field-
   name: field-value" pair, withouanging the semantics of the
   message, by appending each subsequent field-value to the first, each
   separated by a a.




Berners-Lee, et al           Informational                     [Page 22]

RFC 1945                       P/1.0                        May 1996


4.3  General Header Fields

   There are a few header fields which have gen applicability for
   both request and response messages, but which do not apply to the
   entity being transferred. T headers apply only to the message
   being transmitted.

       General-Header = Date                     ; Section 
                      | Pragma                   ; Section 10.12

   General header field names can be extended reli only in
   combination with a change in the protocol version. However, new or
   experimental header fields may be githe semantics of general
   header fields if all parties in the communication recognize them to
   be general header fs. Unrecognized header fields are treated as
   Entity-Header fields.

5. Request

   A request message from a clieo a server includes, within the
   first line of that message, the method to be applied to the resource,
   the identi of the resource, and the protocol version in use. For
   backwards compatibility with the more limited HTTP/0.9 protoc
   there are two valid formats for an HTTP request:

       Request        = Simple-Request | Full-Request

       le-Request = "GET" SP Request-URI CRLF

       Full-Request   = Request-Line             ; Section 5.1
                    *( General-Header        ; Section 4.3
                         | Request-Header        ; Section 5.2
                     | Entity-Header )       ; Section 7.1
                        CRLF
                        [ Entity-Body ]      ; Section 7.2

   If an HTTP/1.0 server receives a Simple-Request, it must respond with
   an HTTP/0.9 Simple-Rese. An HTTP/1.0 client capable of receiving
   a Full-Response should never generate a Simple-Request.

5.1  Request-

   The Request-Line begins with a method token, followed by the
   Request-URI and the protocol version, and endingh CRLF. The
   elements are separated by SP characters. No CR or LF are allowed
   except in the final CRLF sequence.      Request-Line = Method SP Request-URI SP HTTP-Version CRLF



Berners-Lee, et al           Informational                 [Page 23]

RFC 1945                        HTTP/1.0                        May 1996


   Note that the drence between a Simple-Request and the Request-
   Line of a Full-Request is the presence of the HTTP-Version field and the availability of methods other than GET.

5.1.1 Method

   The Method token indicates the method to be performedthe resource
   identified by the Request-URI. The method is case-sensitive.

       Method         = "GET"                ; Section 8.1
                      | "HEAD"                   ; Section 8.2
                      | "POST"               ; Section 8.3
                      | extension-method

       extension-method = token

   The list of mds acceptable by a specific resource can change
   dynamically; the client is notified through the return code of the
esponse if a method is not allowed on a resource. Servers should
   return the status code 501 (not implemented) if thehod is
   unrecognized or not implemented.

   The methods commonly used by HTTP/1.0 applications are fully defined
n Section 8.

5.1.2 Request-URI

   The Request-URI is a Uniform Resource Identifier (Section 3.2) and
   identifiee resource upon which to apply the request.

       Request-URI    = absoluteURI | abs_path

   The two options for est-URI are dependent on the nature of the
   request.

   The absoluteURI form is only allowed when the request is b made
   to a proxy. The proxy is requested to forward the request and return
   the response. If the request is GET oAD and a prior response is
   cached, the proxy may use the cached message if it passes any
   restrictions in the Exp header field. Note that the proxy may
   forward the request on to another proxy or directly to the server
   specifiy the absoluteURI. In order to avoid request loops, a
   proxy must be able to recognize all of its server names, inclu
   any aliases, local variations, and the numeric IP address. An example
   Request-Line would be:

       GET httpww.w3.org/pub/WWW/TheProject.html HTTP/1.0




Berners-Lee, et al           Informational                     [Page

RFC 1945                        HTTP/1.0                        May 1996


   The most common form of Request-UR that used to identify a
   resource on an origin server or gateway. In this case, only the
   absolute path of the UR transmitted (see Section 3.2.1,
   abs_path). For example, a client wishing to retrieve the resource
   above directlom the origin server would create a TCP connection
   to port 80 of the host "www.w3.org" and send the line:

       /pub/WWW/TheProject.html HTTP/1.0

   followed by the remainder of the Full-Request. Note that the absolute
   path ct be empty; if none is present in the original URI, it must
   be given as "/" (the server root).

   The Request-URItransmitted as an encoded string, where some
   characters may be escaped using the "% HEX HEX" encoding defined by
   1738 [4]. The origin server must decode the Request-URI in order
   to properly interpret the request.

5.2  Requestder Fields

   The request header fields allow the client to pass additional
   information about the request, and abthe client itself, to the
   server. These fields act as request modifiers, with semantics
   equivalent to the parame on a programming language method
   (procedure) invocation.

       Request-Header = Authorization            ; Sect10.2
                      | From                     ; Section 10.8
                      | If-Modified-Since        ction 10.9
                      | Referer                  ; Section 10.13
                      | User-Agent           ; Section 10.15

   Request-Header field names can be extended reliably only in
   combination with a change in thotocol version. However, new or
   experimental header fields may be given the semantics of request
   header fields il parties in the communication recognize them to
   be request header fields. Unrecognized header fields are treated as Entity-Header fields.

6.  Response

   After receiving and interpreting a request message, a server responds
   ie form of an HTTP response message.

       Response        = Simple-Response | Full-Response

       Simple-Respons[ Entity-Body ]




Berners-Lee, et al           Informational                     [Page 25]

RFC 1945                    HTTP/1.0                        May 1996


       Full-Response   = Status-Line             ; Section 6.1
                     *( General-Header       ; Section 4.3
                          | Response-Header      ; Section 6                          | Entity-Header )      ; Section 7.1
                         CRLF
                         tity-Body ]         ; Section 7.2

   A Simple-Response should only be sent in response to an HTTP/0.9
   Simple-Requor if the server only supports the more limited
   HTTP/0.9 protocol. If a client sends an HTTP/1.0 Full-Request and
 ceives a response that does not begin with a Status-Line, it should
   assume that the response is a Simple-Response anrse it
   accordingly. Note that the Simple-Response consists only of the
   entity body and is terminated by the servlosing the connection.

6.1  Status-Line

   The first line of a Full-Response message is the Status-Line,
   consig of the protocol version followed by a numeric status code
   and its associated textual phrase, with each element seped by SP
   characters. No CR or LF is allowed except in the final CRLF sequence.

       Status-Line = HTTP-Version tatus-Code SP Reason-Phrase CRLF

   Since a status line always begins with the protocol version and
   status code
     "HTTP/" 1*DIGIT "." 1*DIGIT SP 3DIGIT SP

   (e.g., "HTTP/1.0 200 "), the presence of that expression is
   suffnt to differentiate a Full-Response from a Simple-Response.
   Although the Simple-Response format may allow such an exsion to
   occur at the beginning of an entity body, and thus cause a
   misinterpretation of the message if it was giin response to a
   Full-Request, most HTTP/0.9 servers are limited to responses of type
   "text/html" and therefore d never generate such a response.

6.1.1 Status Code and Reason Phrase

   The Status-Code element is a 3-digit interesult code of the
   attempt to understand and satisfy the request. The Reason-Phrase is
   intended to give a short ual description of the Status-Code. The
   Status-Code is intended for use by automata and the Reason-Phrase is
   intd for the human user. The client is not required to examine or
   display the Reason-Phrase.






Berners-Lee, l           Informational                     [Page 26]

RFC 1945                        HTTP/1.0                    May 1996


   The first digit of the Status-Code defines the class of response. The
   last two digits do not have aategorization role. There are 5
   values for the first digit:

      o 1xx: Informational - Not used, but reserved future use

      o 2xx: Success - The action was successfully received,
             understood, and accepted.

    3xx: Redirection - Further action must be taken in order to
             complete the request

      o 4xx: Client E - The request contains bad syntax or cannot
             be fulfilled

      o 5xx: Server Error - The server failedfulfill an apparently
             valid request

   The individual values of the numeric status codes defined for
 TP/1.0, and an example set of corresponding Reason-Phrase's, are
   presented below. The reason phrases listed here arey recommended
   -- they may be replaced by local equivalents without affecting the
   protocol. These codes are fullyined in Section 9.

       Status-Code    = "200"   ; OK
                      | "201"   ; Created
                  | "202"   ; Accepted
                      | "204"   ; No Content
                      | "301"   ; Moved Permanently                    | "302"   ; Moved Temporarily
                      | "304"   ; Not Modified
                     400"   ; Bad Request
                      | "401"   ; Unauthorized
                      | "403"   ; Forbidden
                  | "404"   ; Not Found
                      | "500"   ; Internal Server Error
                      | "50 ; Not Implemented
                      | "502"   ; Bad Gateway
                      | "503"   ; Service Unavailable                    | extension-code

       extension-code = 3DIGIT

       Reason-Phrase  = *<TEXT, excluding CR, 

   HTTP status codes are extensible, but the above codes are the only
   ones generally recognized in current practiHTTP applications are
   not required to understand the meaning of all registered status



Berners-Lee, et al       Informational                     [Page 27]

RFC 1945                        HTTP/1.0                        May 19

   codes, though such understanding is obviously desirable. However,
   applications must understand the class of atatus code, as
   indicated by the first digit, and treat any unrecognized response as
   being equivalent to the x00 us code of that class, with the
   exception that an unrecognized response must not be cached. For
   example, if an uognized status code of 431 is received by the
   client, it can safely assume that there was something wrong with its
equest and treat the response as if it had received a 400 status
   code. In such cases, user agents should present to user the
   entity returned with the response, since that entity is likely to
   include human-readable information whwill explain the unusual
   status.

6.2  Response Header Fields

   The response header fields allow the server tos additional
   information about the response which cannot be placed in the Status-
   Line. These header fields giveormation about the server and about
   further access to the resource identified by the Request-URI.

       Responseder = Location                ; Section 10.11
                       | Server                  ; Section 10.14
                   | WWW-Authenticate        ; Section 10.16

   Response-Header field names can be extended reliably only in combination with a change in the protocol version. However, new or
   experimental header fields may be given the semas of response
   header fields if all parties in the communication recognize them to
    be response header fields. Ungnized header fields are treated as
   Entity-Header fields.

7.  Entity

   Full-Request and Full-Response messagey transfer an entity within
   some requests and responses. An entity consists of Entity-Header
   fields and (usually Entity-Body. In this section, both sender and
   recipient refer to either the client or the server, depending on whosends and who receives the entity.













Berners-Lee, et al           Informational                 [Page 28]

RFC 1945                        HTTP/1.0                        May 1996


7.1  Entity Header Fields
 Entity-Header fields define optional metainformation about the
   Entity-Body or, if no body is present, about the rese identified
   by the request.

       Entity-Header  = Allow                    ; Section 10.1
                    Content-Encoding         ; Section 10.3
                      | Content-Length           ; Section 10.4
                  | Content-Type             ; Section 10.5
                      | Expires                  ; Section 10.7
                  | Last-Modified            ; Section 10.10
                      | extension-header

       extension-head HTTP-header

   The extension-header mechanism allows additional Entity-Header fields
   to be defined without changthe protocol, but these fields cannot
   be assumed to be recognizable by the recipient. Unrecognized header
   fieldsuld be ignored by the recipient and forwarded by proxies.

7.2  Entity Body

   The entity body (if any) sent with aTP request or response is in
   a format and encoding defined by the Entity-Header fields.

       Entity-Body    = *T

   An entity body is included with a request message only when the
   request method calls for one. The presence o entity body in a
   request is signaled by the inclusion of a Content-Length header field
   in the request message hrs. HTTP/1.0 requests containing an
   entity body must include a valid Content-Length header field.

   For responsesages, whether or not an entity body is included with
   a message is dependent on both the request method and the resp
   code. All responses to the HEAD request method must not include a
   body, even though the presence of entity headields may lead one
   to believe they do. All 1xx (informational), 204 (no content), and
   304 (not modified) responsust not include a body. All other
   responses must include an entity body or a Content-Length header
   field definedh a value of zero (0).

7.2.1 Type

   When an Entity-Body is included with a message, the data type of that
   bod determined via the header fields Content-Type and Content-
   Encoding. These define a two-layer, ordered encoding mod



Berners-Lee, et al           Informational                     [Page 29]

RFC 1945                        HTTP                        May 1996


       entity-body := Content-Encoding( Content-Type( data ) )

   A Content-Typecifies the media type of the underlying data. A
   Content-Encoding may be used to indicate any additional content
  ing applied to the type, usually for the purpose of data
   compression, that is a property of the resource requested. 
   default for the content encoding is none (i.e., the identity
   function).

   Any HTTP/1.0 message containing anity body should include a
   Content-Type header field defining the media type of that body. If
   and only if the medype is not given by a Content-Type header, as
   is the case for Simple-Response messages, the recipient may attempt
  guess the media type via inspection of its content and/or the name
   extension(s) of the URL used to identify the rese. If the media
   type remains unknown, the recipient should treat it as type
   "application/octet-stream".

7.2.2gth

   When an Entity-Body is included with a message, the length of that
   body may be determined in one of two waIf a Content-Length header
   field is present, its value in bytes represents the length of the
   Entity-Body. Otherw the body length is determined by the closing
   of the connection by the server.

   Closing the connection cannot bed to indicate the end of a
   request body, since it leaves no possibility for the server to send
   back a response.refore, HTTP/1.0 requests containing an entity
   body must include a valid Content-Length header field. If a request
ontains an entity body and Content-Length is not specified, and the
   server does not recognize or cannot calculate thngth from other
   fields, then the server should send a 400 (bad request) response.

      Note: Some older servers ly an invalid Content-Length when
      sending a document that contains server-side includes dynamically
      insertnto the data stream. It must be emphasized that this
      will not be tolerated by future versions of HTTP. Unless the    client knows that it is receiving a response from a compliant
      server, it should not depend on the Content-Lenvalue being
      correct.

8.  Method Definitions

   The set of common methods for HTTP/1.0 is defined below. Alth
   this set can be expanded, additional methods cannot be assumed to
   share the same semantics for separately exte clients and servers.




Berners-Lee, et al           Informational                     [Page 30]

RFC 1945                    HTTP/1.0                        May 1996


8.1  GET

   The GET method means retrieve whatever infoion (in the form of an
   entity) is identified by the Request-URI. If the Request-URI refers
   to a data-producing pss, it is the produced data which shall be
   returned as the entity in the response and not the source text of the
  cess, unless that text happens to be the output of the process.

   The semantics of the GET method changes to a "condnal GET" if the
   request message includes an If-Modified-Since header field. A
   conditional GET method requests thhe identified resource be
   transferred only if it has been modified since the date given by the
   If-Modified-Sinceder, as described in Section 10.9. The
   conditional GET method is intended to reduce network usage by
   allowing ca entities to be refreshed without requiring multiple
   requests or transferring unnecessary data.

8.2  HEAD

   TEAD method is identical to GET except that the server must not
   return any Entity-Body in the response. The metainforon contained
   in the HTTP headers in response to a HEAD request should be identical
   to the information sent in rese to a GET request. This method can
   be used for obtaining metainformation about the resource identified
   by the est-URI without transferring the Entity-Body itself. This
   method is often used for testing hypertext links for valid
   accessibility, and recent modification.

   There is no "conditional HEAD" request analogous to the conditional
ET. If an If-Modified-Since header field is included with a HEAD
   request, it should be ignored.

8.3  POST

   TOST method is used to request that the destination server accept
   the entity enclosed in the request as a new subordi of the
   resource identified by the Request-URI in the Request-Line. POST is
   designed to allow a uniform method tver the following functions:

      o Annotation of existing resources;

      o Posting a message to a bulletin boanewsgroup, mailing list,
        or similar group of articles;

      o Providing a block of data, such as the resultsubmitting a
        form [3], to a data-handling process;

      o Extending a database through an append operation.

Berners-Lee, et al           Informational                     [Page 31]

RFC 1945                        HTTP/1.                     May 1996


   The actual function performed by the POST method is determined by the
   server as usually dependent on the Request-URI. The posted entity
   is subordinate to that URI in the same way that a file is rdinate
   to a directory containing it, a news article is subordinate to a
   newsgroup to which it is posted, or a rd is subordinate to a
   database.

   A successful POST does not require that the entity be created as a
   resourc the origin server or made accessible for future
   reference. That is, the action performed by the POST method might n   result in a resource that can be identified by a URI. In this case,
   either 200 (ok) or 204 (no content) is the apriate response
   status, depending on whether or not the response includes an entity
   that describes the result.
If a resource has been created on the origin server, the response
   should be 201 (created) and contain an entity (prebly of type
   "text/html") which describes the status of the request and refers to
   the new resource.

   A validtent-Length is required on all HTTP/1.0 POST requests. An
   HTTP/1.0 server should respond with a 400 (bad request) mee if it
   cannot determine the length of the request message's content.

   Applications must not cache responses toOST request because the
   application has no way of knowing that the server would return an
   equivalent response one future request.

9.  Status Code Definitions

   Each Status-Code is described below, including a description of w
   method(s) it can follow and any metainformation required in the
   response.

9.1  Informational 1xx

   This s of status code indicates a provisional response,
   consisting only of the Status-Line and optional headers, and is
erminated by an empty line. HTTP/1.0 does not define any 1xx status
   codes and they are not a valid response to a HTT0 request.
   However, they may be useful for experimental applications which are
   outside the scope of this specifion.

9.2  Successful 2xx

   This class of status code indicates that the client's request was
   successfully rece, understood, and accepted.




Berners-Lee, et al           Informational                     [Page 32]

RFC 19                      HTTP/1.0                        May 1996


   200 OK

   The request has succeeded. The inforon returned with the
   response is dependent on the method used in the request, as follows:

   GET    an entity coronding to the requested resource is sent
          in the response;

   HEAD   the response must only contain the heainformation and
          no Entity-Body;

   POST   an entity describing or containing the result of the action.

01 Created

   The request has been fulfilled and resulted in a new resource being
   created. The newly created reso can be referenced by the URI(s)
   returned in the entity of the response. The origin server should
   create the rese before using this Status-Code. If the action
   cannot be carried out immediately, the server must include in the
  ponse body a description of when the resource will be available;
   otherwise, the server should respond with 202 (acce).

   Of the methods defined by this specification, only POST can create a
   resource.

   202 Accepted

   Theuest has been accepted for processing, but the processing
   has not been completed. The request may or may not eventuabe
   acted upon, as it may be disallowed when processing actually takes
   place. There is no facility for re-sendingtatus code from an
   asynchronous operation such as this.

   The 202 response is intentionally non-committal. Its pse is to
   allow a server to accept a request for some other process (perhaps
   a batch-oriented process that is onln once per day) without
   requiring that the user agent's connection to the server persist
   until the process is coted. The entity returned with this
   response should include an indication of the request's current
   status and eita pointer to a status monitor or some estimate of
   when the user can expect the request to be fulfilled.

   204 Notent

   The server has fulfilled the request but there is no new
   information to send back. If the client is a useent, it should
   not change its document view from that which caused the request to



Berners-Lee, et al         formational                     [Page 33]

RFC 1945                        HTTP/1.0                        May 1996
   be generated. This response is primarily intended to allow input
   for scripts or other actions to take place withoausing a change
   to the user agent's active document view. The response may include
   new metainformation in the fof entity headers, which should
   apply to the document currently in the user agent's active view.

9.3  Redirection 

   This class of status code indicates that further action needs to be
   taken by the user agent in order to fulfile request. The action
   required may be carried out by the user agent without interaction
   with the user if and onl the method used in the subsequent
   request is GET or HEAD. A user agent should never automatically
   redirect a ret more than 5 times, since such redirections usually
   indicate an infinite loop.

   300 Multiple Choices

   Thisponse code is not directly used by HTTP/1.0 applications,
   but serves as the default for interpreting the 3xx class    responses.

   The requested resource is available at one or more locations.
   Unless it was a HEAD request, the onse should include an entity
   containing a list of resource characteristics and locations from
   which the user orr agent can choose the one most appropriate.
   If the server has a preferred choice, it should include the URL in
   cation field; user agents may use this field value for
   automatic redirection.

   301 Moved Permanently

   The ested resource has been assigned a new permanent URL and
   any future references to this resource should be done usingt
   URL. Clients with link editing capabilities should automatically
   relink references to the Request-URI to the neference returned
   by the server, where possible.

   The new URL must be given by the Location field in the respon
   Unless it was a HEAD request, the Entity-Body of the response
   should contain a short note with a hyperlink to thw URL.

   If the 301 status code is received in response to a request using
   the POST method, the user agent must automatically redirect the
   request unless it can be confirmed by the user, since this might
   change the conditionder which the request was issued.





Berners-Lee, et al           Informational                     [Page 34]
C 1945                        HTTP/1.0                        May 1996


       Note: When automatically redirecting ST request after
       receiving a 301 status code, some existing user agents will
       erroneously change it into T request.

   302 Moved Temporarily

   The requested resource resides temporarily under a different URL.
   Since redirection may be altered on occasion, the client should
   continue to use the Request-URI for future requests.

 e URL must be given by the Location field in the response. Unless
   it was a HEAD request, the Entity-Body of the resp should
   contain a short note with a hyperlink to the new URI(s).

   If the 302 status code is received in respons a request using
   the POST method, the user agent must not automatically redirect the
   request unless it can be comed by the user, since this might
   change the conditions under which the request was issued.

       Note: When autically redirecting a POST request after
       receiving a 302 status code, some existing user agents will
       errosly change it into a GET request.

   304 Not Modified

   If the client has performed a conditional GET request andess is
   allowed, but the document has not been modified since the date and
   time specified in the If-Modified-Sinceld, the server must
   respond with this status code and not send an Entity-Body to the
   client. Header fields contd in the response should only include
   information which is relevant to cache managers or which may have
   changed pendently of the entity's Last-Modified date. Examples
   of relevant header fields include: Date, Server, and Expires.   cache should update its cached entity to reflect any new field
   values given in the 304 response.

9.4  Client E 4xx

   The 4xx class of status code is intended for cases in which the
   client seems to have erred. If the client not completed the
   request when a 4xx code is received, it should immediately cease
   sending data to the server. pt when responding to a HEAD request,
   the server should include an entity containing an explanation of the
   erroruation, and whether it is a temporary or permanent
   condition. These status codes are applicable to any request metho





Berners-Lee, et al           Informational                     [Page 35]

RFC 1945                       P/1.0                        May 1996


      Note: If the client is sending data, server implementations on TCP
   hould be careful to ensure that the client acknowledges receipt
      of the packet(s) containing the response prior tosing the
      input connection. If the client continues sending data to the
      server after the close, the server'ntroller will send a reset
      packet to the client, which may erase the client's unacknowledged
      input buffersore they can be read and interpreted by the HTTP
      application.

   400 Bad Request

   The request could not bderstood by the server due to malformed
   syntax. The client should not repeat the request without
   modifications.  401 Unauthorized

   The request requires user authentication. The response must include
   a WWW-Authenticate headield (Section 10.16) containing a
   challenge applicable to the requested resource. The client may
   repeat the requwith a suitable Authorization header field
   (Section 10.2). If the request already included Authorization
   credent, then the 401 response indicates that authorization has
   been refused for those credentials. If the 401 response cons
   the same challenge as the prior response, and the user agent has
   already attempted authentication at least onchen the user
   should be presented the entity that was given in the response,
   since that entity may include relevaiagnostic information. HTTP
   access authentication is explained in Section 11.

   403 Forbidden

   The server ustood the request, but is refusing to fulfill it.
   Authorization will not help and the request should not be repeated  If the request method was not HEAD and the server wishes to make
   public why the request has not been fulfilled, ituld describe
   the reason for the refusal in the entity body. This status code is
   commonly used when the server doot wish to reveal exactly why
   the request has been refused, or when no other response is
   applicable.

   404 Nound

   The server has not found anything matching the Request-URI. No
   indication is given of whether the conditis temporary or
   permanent. If the server does not wish to make this information
   available to the client, the statode 403 (forbidden) can be
   used instead.



Berners-Lee, et al           Informational                     [Page

RFC 1945                        HTTP/1.0                        May 1996


9.5  Server Error 5xx

   Response us codes beginning with the digit "5" indicate cases in
   which the server is aware that it has erred or is incapable    performing the request. If the client has not completed the request
   when a 5xx code is received, it should immediy cease sending data
   to the server. Except when responding to a HEAD request, the server
   should include an entitntaining an explanation of the error
   situation, and whether it is a temporary or permanent condition.
   These resp codes are applicable to any request method and there
   are no required header fields.

   500 Internal Server Error   The server encountered an unexpected condition which prevented it
   from fulfilling the request.

   501 Not Implted

   The server does not support the functionality required to fulfill
   the request. This is the appropriate rese when the server does
   not recognize the request method and is not capable of supporting
   it for any resource.
502 Bad Gateway

   The server, while acting as a gateway or proxy, received an invalid
   response from the upstreamver it accessed in attempting to
   fulfill the request.

   503 Service Unavailable

   The server is currently un to handle the request due to a
   temporary overloading or maintenance of the server. The implication
   is that thisa temporary condition which will be alleviated
   after some delay.

       Note: The existence of the 503 status codes not imply
       that a server must use it when becoming overloaded. Some
       servers may wish to simply refuse connection.

10.  Header Field Definitions

   This section defines the syntax and semantics of all commonly used
 TP/1.0 header fields. For general and entity header fields, both
   sender and recipient refer to either the client or server,
   depending on who sends and who receives the message.




Berners-Lee, et al           Informational                 [Page 37]

RFC 1945                        HTTP/1.0                        May 1996


10.1  Allow

he Allow entity-header field lists the set of methods supported by
   the resource identified by the Request-URI. The pse of this field
   is strictly to inform the recipient of valid methods associated with
   the resource. The Allow he field is not permitted in a request
   using the POST method, and thus should be ignored if it is received
   as parta POST entity.

       Allow          = "Allow" ":" 1#method

    Example of use:

       Allow: GET, HEAD

   Tfield cannot prevent a client from trying other methods.
   However, the indications given by the Allow header field vashould
   be followed. The actual set of allowed methods is defined by the
   origin server at the time of each reques
   A proxy must not modify the Allow header field even if it does not
   understand all the methods specified, since user agent may have
   other means of communicating with the origin server.

   The Allow header field does not indicwhat methods are implemented
   by the server.

10.2  Authorization

   A user agent that wishes to authenticate it with a server--
   usually, but not necessarily, after receiving a 401 response--may do
   so by including an Authorion request-header field with the
   request. The Authorization field value consists of credentials
   containing the antication information of the user agent for the
   realm of the resource being requested.

       Authorization  = "Arization" ":" credentials

   HTTP access authentication is described in Section 11. If a request
   is authenticated a realm specified, the same credentials should
   be valid for all other requests within this realm.

   Responses tquests containing an Authorization field are not
   cachable.







Berners-Lee, et al           Informational                 [Page 38]

RFC 1945                        HTTP/1.0                        May 1996


10.3  Contencoding

   The Content-Encoding entity-header field is used as a modifier to the
   media-type. When present, its vaindicates what additional content
   coding has been applied to the resource, and thus what decoding
   mechanism mustapplied in order to obtain the media-type
   referenced by the Content-Type header field. The Content-Encoding is
   prily used to allow a document to be compressed without losing
   the identity of its underlying media type.

       Cnt-Encoding = "Content-Encoding" ":" content-coding

   Content codings are defined in Section 3.5. An example of its is

       Content-Encoding: x-gzip

   The Content-Encoding is a characteristic of the resource identified
   by tequest-URI. Typically, the resource is stored with this
   encoding and is only decoded before rendering or analogous u.

10.4  Content-Length

   The Content-Length entity-header field indicates the size of the
   Entity-Body, in dec number of octets, sent to the recipient or,
   in the case of the HEAD method, the size of the Entity-Body that
   wohave been sent had the request been a GET.

       Content-Length = "Content-Length" ":" 1*DIGIT

   An example is
     Content-Length: 3495

   Applications should use this field to indicate the size of the
   Entity-Body to be trarred, regardless of the media type of the
   entity. A valid Content-Length field value is required on all
   HTTP/1.0uest messages containing an entity body.

   Any Content-Length greater than or equal to zero is a valid value.
   Sen 7.2.2 describes how to determine the length of a response
   entity body if a Content-Length is not given.

      N The meaning of this field is significantly different from
      the corresponding definition in MIME, where it is an onal
      field used within the "message/external-body" content-type. In
      HTTP, it should be used whenever the en's length can be
      determined prior to being transferred.




Berners-Lee, et al           Informational                 [Page 39]

RFC 1945                        HTTP/1.0                        May 1996


10.5  Content-Typ
   The Content-Type entity-header field indicates the media type of the
   Entity-Body sent to the recipient or, in thse of the HEAD method,
   the media type that would have been sent had the request been a GET.

       Content-Type  Content-Type" ":" media-type

   Media types are defined in Section 3.6. An example of the field is

       Content-: text/html

   Further discussion of methods for identifying the media type of an
   entity is provided in Section 7.

10.6  Date

   The Date general-header field represents the date and time at which
   the message was originatedving the same semantics as orig-date in
   RFC 822. The field value is an HTTP-date, as described in Section
   3.3.
     Date           = "Date" ":" HTTP-date

   An example is

       Date: Tue, 15 Nov 1994 08:12:31 GMT

   If a age is received via direct connection with the user agent
   (in the case of requests) or the origin server (in the cas
   responses), then the date can be assumed to be the current date at
   the receiving end. However, since the date--t is believed by the
   origin--is important for evaluating cached responses, origin servers
   should always include te header. Clients should only send a Date
   header field in messages that include an entity body, as in the case
   he POST request, and even then it is optional. A received message
   which does not have a Date header field should be gned one by the
   recipient if the message will be cached by that recipient or
   gatewayed via a protocol which requ a Date.

   In theory, the date should represent the moment just before the
   entity is generated. In practice, thee can be generated at any
   time during the message origination without affecting its semantic
   value.

      Notn earlier version of this document incorrectly specified
      that this field should contain the creation date of the osed
      Entity-Body. This has been changed to reflect actual (and proper)



Berners-Lee, et al           Informnal                     [Page 40]

RFC 1945                        HTTP/1.0                        May 1996


    age.

10.7  Expires

   The Expires entity-header field gives the date/time after which the
   entity should be conred stale. This allows information providers
   to suggest the volatility of the resource, or a date after which the
 formation may no longer be valid. Applications must not cache this
   entity beyond the date given. The presence of an res field does
   not imply that the original resource will change or cease to exist
   at, before, or after that timewever, information providers that
   know or even suspect that a resource will change by a certain date
   should inclan Expires header with that date. The format is an
   absolute date and time as defined by HTTP-date in Section 3.3.
    Expires        = "Expires" ":" HTTP-date

   An example of its use is

       Expires: Thu, 01 Dec 1994 16:00:00

   If the date given is equal to or earlier than the value of the Date
   header, the recipient must not cache the osed entity. If a
   resource is dynamic by nature, as is the case with many data-
   producing processes, entities frhat resource should be given an
   appropriate Expires value which reflects that dynamism.

   The Expires field canne used to force a user agent to refresh its
   display or reload a resource; its semantics apply only to caching
   meisms, and such mechanisms need only check a resource's
   expiration status when a new request for that resource is inied.

   User agents often have history mechanisms, such as "Back" buttons and
   history lists, which can be used to splay an entity retrieved
   earlier in a session. By default, the Expires field does not apply to
   history mechanisIf the entity is still in storage, a history
   mechanism should display it even if the entity has expired, unless
   user has specifically configured the agent to refresh expired
   history documents.

      Note: Applications are encged to be tolerant of bad or
      misinformed implementations of the Expires header. A value of zero
      (0) or an lid date format should be considered equivalent to
      an "expires immediately." Although these values are not legiti
      for HTTP/1.0, a robust implementation is always desirable.






Berners-Lee, et al           Information                   [Page 41]

RFC 1945                        HTTP/1.0                        May 1996


10.8  Fro
   The From request-header field, if given, should contain an Internet
   e-mail address for the human user who controhe requesting user
   agent. The address should be machine-usable, as defined by mailbox in
   RFC 822 [7] (as updatedRFC 1123 [6]):

       From           = "From" ":" mailbox

   An example is:

       From: webmaster@w3.org

  s header field may be used for logging purposes and as a means for
   identifying the source of invalid or unwanted reqs. It should not
   be used as an insecure form of access protection. The interpretation
   of this field is that the est is being performed on behalf of the
   person given, who accepts responsibility for the method performed. In
   paular, robot agents should include this header so that the
   person responsible for running the robot can be contacted roblems
   occur on the receiving end.

   The Internet e-mail address in this field may be separate from the
   Intt host which issued the request. For example, when a request
   is passed through a proxy, the original issuer's addresould be
   used.

      Note: The client should not send the From header field without the
      user's approval, asmay conflict with the user's privacy
      interests or their site's security policy. It is strongly
      recommendedt the user be able to disable, enable, and modify
      the value of this field at any time prior to a request.

10.9-Modified-Since

   The If-Modified-Since request-header field is used with the GET
   method to make it conditional:the requested resource has not been
   modified since the time specified in this field, a copy of the
   resource will be returned from the server; instead, a 304 (not
   modified) response will be returned without any Entity-Body.

   If-Modified-Since = "If-Modified-Since" ":" HTTP-date

   An example of the field is:

       If-Modified-Since: Sa9 Oct 1994 19:43:31 GMT





Berners-Lee, et al           Informational                     [Page 42]

RFC 1945                    HTTP/1.0                        May 1996


   A conditional GET method requests that the identifiesource be
   transferred only if it has been modified since the date given by the
   If-Modified-Since header. The althm for determining this includes
   the following cases:

      a) If the request would normally result in anything r than
         a 200 (ok) status, or if the passed If-Modified-Since date
         is invalid, the response is exactle same as for a
         normal GET. A date which is later than the server's current
         time is invalid.

     If the resource has been modified since the
         If-Modified-Since date, the response is exactly the same as
     for a normal GET.

      c) If the resource has not been modified since a valid
         If-Modified-Since date, thever shall return a 304 (not
         modified) response.

   The purpose of this feature is to allow efficient update cached
   information with a minimum amount of transaction overhead.

10.10  Last-Modified

   The Last-Modified ey-header field indicates the date and time at
   which the sender believes the resource was last modified. The exact
 mantics of this field are defined in terms of how the recipient
   should interpret it:  if the recipient has a copy ofs resource
   which is older than the date given by the Last-Modified field, that
   copy should be considered stale.      Last-Modified  = "Last-Modified" ":" HTTP-date

   An example of its use is

       Last-Modified: Tue, 15 Nov4 12:45:26 GMT

   The exact meaning of this header field depends on the implementation
   of the sender and the natuf the original resource. For files, it
   may be just the file system last-modified time. For entities with
   dynamic included parts, it may be the most recent of the set of
   last-modify times for its component parts. For database gats, it
   may be the last-update timestamp of the record. For virtual objects,
   it may be the last time the internal e changed.

   An origin server must not send a Last-Modified date which is later
   than the server's time of messagigination. In such cases, where
   the resource's last modification would indicate some time in the



Berners-Lee,al           Informational                     [Page 43]

RFC 1945                        HTTP/1.0                    May 1996


   future, the server must replace that date with the message
   origination date.

10.11  Location
The Location response-header field defines the exact location of the
   resource that was identified by the Request-URIr 3xx responses,
   the location must indicate the server's preferred URL for automatic
   redirection to the resourcely one absolute URL is allowed.

       Location       = "Location" ":" absoluteURI

   An example is

       Loca: http://www.w3.org/hypertext/WWW/NewLocation.html

10.12  Pragma

   The Pragma general-header field is used to inc implementation-
   specific directives that may apply to any recipient along the
   request/response chain. All pragmrectives specify optional
   behavior from the viewpoint of the protocol; however, some systems
   may require that beor be consistent with the directives.

       Pragma           = "Pragma" ":" 1#pragma-directive

       pragma-diree = "no-cache" | extension-pragma
       extension-pragma = token [ "=" word ]

   When the "no-cache" directive is pnt in a request message, an
   application should forward the request toward the origin server even
   if it has a caccopy of what is being requested. This allows a
   client to insist upon receiving an authoritative response to its
   est. It also allows a client to refresh a cached copy which is
   known to be corrupted or stale.

   Pragma directivust be passed through by a proxy or gateway
   application, regardless of their significance to that application,
   s the directives may be applicable to all recipients along the
   request/response chain. It is not possible to specify agma for a
   specific recipient; however, any pragma directive not relevant to a
   recipient should be ignored by thecipient.

10.13  Referer

   The Referer request-header field allows the client to specify, for
   the server's bet, the address (URI) of the resource from which
   the Request-URI was obtained. This allows a server to generate lists

Berners-Lee, et al           Informational                     [Page 44]

RFC 1945                        HTTP/1.                     May 1996


   of back-links to resources for interest, logging, optimized caching,
   etc. It aallows obsolete or mistyped links to be traced for
   maintenance. The Referer field must not be sent if the Request-UR  was obtained from a source that does not have its own URI, such as
   input from the user keyboard.

       Referer    = "Referer" ":" ( absoluteURI | relativeURI )

   Example:

       Referer: http://www.w3.org/hypertext/DataSourOverview.html

   If a partial URI is given, it should be interpreted relative to the
   Request-URI. The URI must noclude a fragment.

      Note: Because the source of a link may be private information or
      may reveal an otherwirivate information source, it is strongly
      recommended that the user be able to select whether or not the
      Rer field is sent. For example, a browser client could have a
      toggle switch for browsing openly/anonymously, whichld
      respectively enable/disable the sending of Referer and From
      information.

10.14  Server

   The Serresponse-header field contains information about the
   software used by the origin server to handle the request. The f
   can contain multiple product tokens (Section 3.7) and comments
   identifying the server and any significant subprts. By
   convention, the product tokens are listed in order of their
   significance for identifying the application.       Server         = "Server" ":" 1*( product | comment )

   Example:

       Server: CERN/3.0 libwww/2.17

  the response is being forwarded through a proxy, the proxy
   application must not add its data to the product list.
   Note: Revealing the specific software version of the server may
      allow the server machine to become more vulner to attacks
      against software that is known to contain security holes. Server
      implementors are encouraged tke this field a configurable
      option.





Berners-Lee, et al           Informational                     [P45]

RFC 1945                        HTTP/1.0                        May 1996


      Note: Some existing servers  to restrict themselves to the
      product token syntax within the Server field.

10.15  User-Agent

   The User-t request-header field contains information about the
   user agent originating the request. This is for statistical pues,
   the tracing of protocol violations, and automated recognition of user
   agents for the sake of tailoring respo to avoid particular user
   agent limitations. Although it is not required, user agents should
   include this field  requests. The field can contain multiple
   product tokens (Section 3.7) and comments identifying the agent and
   anbproducts which form a significant part of the user agent. By
   convention, the product tokens are listed in order of r
   significance for identifying the application.

       User-Agent     = "User-Agent" ":" 1*( product | comment )  Example:

       User-Agent: CERN-LineMode/2.15 libwww/2.17b3

       Note: Some current proxy applications appendir product
       information to the list in the User-Agent field. This is not
       recommended, since it makes machinterpretation of these
       fields ambiguous.

       Note: Some existing clients fail to restrict themselves to
   the product token syntax within the User-Agent field.

10.16  WWW-Authenticate

   The WWW-Authenticate response-er field must be included in 401
   (unauthorized) response messages. The field value consists of at
   least one chale that indicates the authentication scheme(s) and
   parameters applicable to the Request-URI.

       WWW-Authentica "WWW-Authenticate" ":" 1#challenge

   The HTTP access authentication process is described in Section 11.
   User ag must take special care in parsing the WWW-Authenticate
   field value if it contains more than one challenge, or if mohan
   one WWW-Authenticate header field is provided, since the contents of
   a challenge may itself contain a comma-rated list of
   authentication parameters.






Berners-Lee, et al           Informational                    ge 46]

RFC 1945                        HTTP/1.0                        May 1996


11.  Access Authentication

 TP provides a simple challenge-response authentication mechanism
   which may be used by a server to challenge a clientuest and by a
   client to provide authentication information. It uses an extensible,
   case-insensitive token to idey the authentication scheme,
   followed by a comma-separated list of attribute-value pairs which
   carry the parametnecessary for achieving authentication via that
   scheme.

       auth-scheme    = token

       auth-param     = n "=" quoted-string

   The 401 (unauthorized) response message is used by an origin server
   to challenge the authotion of a user agent. This response must
   include a WWW-Authenticate header field containing at least one
   challenpplicable to the requested resource.

       challenge      = auth-scheme 1*SP realm *( "," auth-param )

       rea        = "realm" "=" realm-value
       realm-value    = quoted-string

   The realm attribute (case-insensitive) isuired for all
   authentication schemes which issue a challenge. The realm value
   (case-sensitive), in combination wthe canonical root URL of the
   server being accessed, defines the protection space. These realms
   allow the protecresources on a server to be partitioned into a
   set of protection spaces, each with its own authentication scheme
  /or authorization database. The realm value is a string, generally
   assigned by the origin server, which may have addnal semantics
   specific to the authentication scheme.

   A user agent that wishes to authenticate itself with a se--
   usually, but not necessarily, after receiving a 401 response--may do
   so by including an Authorization header d with the request. The
   Authorization field value consists of credentials containing the
   authentication informatof the user agent for the realm of the
   resource being requested.

       credentials    = basic-credentials
                  | ( auth-scheme #auth-param )

   The domain over which credentials can be automatically applied by a
  r agent is determined by the protection space. If a prior request
   has been authorized, the same credentials may be rd for all other
   requests within that protection space for a period of time determined



Berners-Lee, et al       Informational                     [Page 47]

RFC 1945                        HTTP/1.0                        May 19

   by the authentication scheme, parameters, and/or user preference.
   Unless otherwise defined by the authenticatscheme, a single
   protection space cannot extend outside the scope of its server.

   If the server does not wish tcept the credentials sent with a
   request, it should return a 403 (forbidden) response.

   The HTTP protocol does restrict applications to this simple
   challenge-response mechanism for access authentication. Additional
   mechanisay be used, such as encryption at the transport level or
   via message encapsulation, and with additional header field  specifying authentication information. However, these additional
   mechanisms are not defined by this specification.   Proxies must be completely transparent regarding user agent
   authentication. That is, they must forward the WWW-Auticate and
   Authorization headers untouched, and must not cache the response to a
   request containing AuthorizatioTTP/1.0 does not provide a means
   for a client to be authenticated with a proxy.

11.1  Basic Authentication Scheme   The "basic" authentication scheme is based on the model that the user
   agent must authenticate itself with a user-nd a password for each
   realm. The realm value should be considered an opaque string which
   can only be compared fquality with other realms on that server.
   The server will authorize the request only if it can validate the
   userand password for the protection space of the Request-URI.
   There are no optional authentication parameters.

   Upoceipt of an unauthorized request for a URI within the
   protection space, the server should respond with a challenge lthe
   following:

       WWW-Authenticate: Basic realm="WallyWorld"

   where "WallyWorld" is the string assigned he server to identify
   the protection space of the Request-URI.

   To receive authorization, the client sends the -ID and password,
   separated by a single colon (":") character, within a base64 [5]
   encoded string in the credent.

       basic-credentials = "Basic" SP basic-cookie

       basic-cookie      = <base64 [5] encoding of userid-pasd,
                            except not limited to 76 char/line>




Berners-Lee, et al           Informational                 [Page 48]

RFC 1945                        HTTP/1.0                        May 1996


       userissword   = [ token ] ":" *TEXT

   If the user agent wishes to send the user-ID "Aladdin" and password
   "open sesamit would use the following header field:

       Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==

   The basic autication scheme is a non-secure method of filtering
   unauthorized access to resources on an HTTP server. It is based o  the assumption that the connection between the client and the server
   can be regarded as a trusted carrier. As thisnot generally true
   on an open network, the basic authentication scheme should be used
   accordingly. In spite of t clients should implement the scheme in
   order to communicate with servers that use it.

12.  Security Consideratio
   This section is meant to inform application developers, information
   providers, and users of the security limitas in HTTP/1.0 as
   described by this document. The discussion does not include
   definitive solutions to the problemvealed, though it does make
   some suggestions for reducing security risks.

12.1  Authentication of Clients

   Antioned in Section 11.1, the Basic authentication scheme is not
   a secure method of user authentication, nor does it ent the
   Entity-Body from being transmitted in clear text across the physical
   network used as the carrier. HTTP/1oes not prevent additional
   authentication schemes and encryption mechanisms from being employed
   to increase secu.

12.2  Safe Methods

   The writers of client software should be aware that the software
   represents the user ieir interactions over the Internet, and
   should be careful to allow the user to be aware of any actions they
   may  which may have an unexpected significance to themselves or
   others.

   In particular, the convention has been estshed that the GET and
   HEAD methods should never have the significance of taking an action
   other than retrieval. e methods should be considered "safe." This
   allows user agents to represent other methods, such as POST, in a
   spl way, so that the user is made aware of the fact that a
   possibly unsafe action is being requested.





Berneee, et al           Informational                     [Page 49]

RFC 1945                        HTTP/1.0                    May 1996


   Naturally, it is not possible to ensure that the server does not
   generate side-effects as ault of performing a GET request; in
   fact, some dynamic resources consider that a feature. The important
   distincthere is that the user did not request the side-effects,
   so therefore cannot be held accountable for them.

12.3  A of Server Log Information

   A server is in the position to save personal data about a user's
   requests which mayntify their reading patterns or subjects of
   interest. This information is clearly confidential in nature and its
  dling may be constrained by law in certain countries. People using
   the HTTP protocol to provide data are responsible ensuring that
   such material is not distributed without the permission of any
   individuals that are identifiable he published results.

12.4  Transfer of Sensitive Information

   Like any generic data transfer protocol, HTTP canregulate the
   content of the data that is transferred, nor is there any a priori
   method of determining the sensity of any particular piece of
   information within the context of any given request. Therefore,
   applications shouldply as much control over this information as
   possible to the provider of that information. Three header fields are
orth special mention in this context: Server, Referer and From.

   Revealing the specific software version of the sermay allow the
   server machine to become more vulnerable to attacks against software
   that is known to contain secu holes. Implementors should make the
   Server header field a configurable option.

   The Referer field allows readiatterns to be studied and reverse
   links drawn. Although it can be very useful, its power can be abused
   if user dls are not separated from the information contained in
   the Referer. Even when the personal information has been remo the
   Referer field may indicate a private document's URI whose publication
   would be inappropriate.

   The inftion sent in the From field might conflict with the user's
   privacy interests or their site's security policy, and heit
   should not be transmitted without the user being able to disable,
   enable, and modify the contents of the fielhe user must be able
   to set the contents of this field within a user preference or
   application defaults configurn.

   We suggest, though do not require, that a convenient toggle interface
   be provided for the user to enable orable the sending of From and
   Referer information.



Berners-Lee, et al           Informational                 [Page 50]

RFC 1945                        HTTP/1.0                        May 1996


12.5  Attacks Based On File Path Names

   Implementations of HTTP origin servers should be careful to restrict
   the documents returned by HTTPuests to be only those that were
   intended by the server administrators. If an HTTP server translates
   HTTP URIs dtly into file system calls, the server must take
   special care not to serve files that were not intended to be
   dered to HTTP clients. For example, Unix, Microsoft Windows, and
   other operating systems use ".." as a path component ndicate a
   directory level above the current one. On such a system, an HTTP
   server must disallow any such construn the Request-URI if it
   would otherwise allow access to a resource outside those intended to
   be accessible via tTTP server. Similarly, files intended for
   reference only internally to the server (such as access control
   files,figuration files, and script code) must be protected from
   inappropriate retrieval, since they might contain sensitiv  information. Experience has shown that minor bugs in such HTTP server
   implementations have turned into security ri

13.  Acknowledgments

   This specification makes heavy use of the augmented BNF and generic
   constructs define David H. Crocker for RFC 822 [7]. Similarly, it
   reuses many of the definitions provided by Nathaniel Borenstein and Ned Freed for MIME [5]. We hope that their inclusion in this
   specification will help reduce past confusion over theationship
   between HTTP/1.0 and Internet mail message formats.

   The HTTP protocol has evolved considerably over past four years.
   It has benefited from a large and active developer community--the
   many people who have particip on the www-talk mailing list--and
   it is that community which has been most responsible for the success
   of HTTP of the World-Wide Web in general. Marc Andreessen, Robert
   Cailliau, Daniel W. Connolly, Bob Denny, Jean-Francois GroPhillip
   M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob McCool, Lou
   Montulli, Dave Raggett, Tony Sanders, and MVanHeyningen deserve
   special recognition for their efforts in defining aspects of the
   protocol for early version this specification.

   Paul Hoffman contributed sections regarding the informational status
   of this document andendices C and D.










Berners-Lee, et al           Informational                     [Page 51]

RFC 1                       HTTP/1.0                        May 1996


   This document has benefited greatly from the coms of all those
   participating in the HTTP-WG. In addition to those already mentioned,
   the following individuals hcontributed to this specification:

       Gary Adams                         Harald Tveit Alvestrand
       Keith Ba                       Brian Behlendorf
       Paul Burchard                      Maurizio Codogno
       Mike Cowlish                   Roman Czyborra
       Michael A. Dolan                   John Franks
       Jim Gettys                     Marc Hedlund
       Koen Holtman                       Alex Hopmann
       Bob Jernigan                        Kaphan
       Martijn Koster                     Dave Kristol
       Daniel LaLiberte                   Paul Leach
   Albert Lunde                       John C. Mallery
       Larry Masinter                     Mitra
       Jeffrey Mo                     Gavin Nicol
       Bill Perry                         Jeffrey Perry
       Owen Rees                      Luigi Rizzo
       David Robinson                     Marc Salomon
       Rich Salz                          Seidman
       Chuck Shotton                      Eric W. Sink
       Simon E. Spero                     Robert S. Tha      Francois Yergeau                   Mary Ellen Zurko
       Jean-Philippe Martin-Flatin

14. References

   [1nklesaria, F., McCahill, M., Lindner, P., Johnson, D.,
        Torrey, D., and B. Alberti, "The Internet Gopher Protoco
        Distributed Document Search and Retrieval Protocol", RFC 1436,
        University of Minnesota, March 1993.
 [2]  Berners-Lee, T., "Universal Resource Identifiers in WWW: A
        Unifying Syntax for the Expression of Names andresses of
        Objects on the Network as used in the World-Wide Web",
        RFC 1630, CERN, June 1994.

   [3]rners-Lee, T., and D. Connolly, "Hypertext Markup Language -
        2.0", RFC 1866, MIT/W3C, November 1995.

   [4] ners-Lee, T., Masinter, L., and M. McCahill, "Uniform
        Resource Locators (URL)", RFC 1738, CERN, Xerox PARC,
    University of Minnesota, December 1994.







Berners-Lee, et al           Informational                     e 52]

RFC 1945                        HTTP/1.0                        May 1996


   [5]  Borenstein, N., and N. F, "MIME (Multipurpose Internet Mail
        Extensions) Part One: Mechanisms for Specifying and Describing
        themat of Internet Message Bodies", RFC 1521, Bellcore,
        Innosoft, September 1993.

   [6]  Braden, R., "Requirem for Internet hosts - Application and
        Support", STD 3, RFC 1123, IETF, October 1989.

   [7]  Crocker, D., "Sard for the Format of ARPA Internet Text
        Messages", STD 11, RFC 822, UDEL, August 1982.

   [8]  F. Davis, B.le, H. Morris, J. Salem, T. Shen, R. Wang,
        J. Sui, and M. Grinbaum. "WAIS Interface Protocol Prototype
       ctional Specification." (v1.5), Thinking Machines
        Corporation, April 1990.

   [9]  Fielding, R., "Relative Urm Resource Locators", RFC 1808,
        UC Irvine, June 1995.

   [10] Horton, M., and R. Adams, "Standard for interge of USENET
        Messages", RFC 1036 (Obsoletes RFC 850), AT&T Bell
        Laboratories, Center for Seismic StudiDecember 1987.

   [11] Kantor, B., and P. Lapsley, "Network News Transfer Protocol:
        A Proposed Standard for Stream-Based Transmission of News",
        RFC 977, UC San Diego, UC Berkeley, February 1986.

   [12] Postel, J., "le Mail Transfer Protocol." STD 10, RFC 821,
        USC/ISI, August 1982.

   [13] Postel, J., "Media Type RegistratProcedure." RFC 1590,
        USC/ISI, March 1994.

   [14] Postel, J., and J. Reynolds, "File Transfer Protocol (FTP
        STD 9, RFC 959, USC/ISI, October 1985.

   [15] Reynolds, J., and J. Postel, "Assigned Numbers", STD 2, RFC
    1700, USC/ISI, October 1994.

   [16] Sollins, K., and L. Masinter, "Functional Requirements for
        Uniform urce Names", RFC 1737, MIT/LCS, Xerox Corporation,
        December 1994.

   [17] US-ASCII. Coded Character Set - 7-American Standard Code
        for Information Interchange. Standard ANSI X3.4-1986, ANSI,
        1986.





Bes-Lee, et al           Informational                     [Page 53]

RFC 1945                        HTTP/1.0                    May 1996


   [18] ISO-8859. International Standard -- Information Processing --
        8-bit Single-Bytded Graphic Character Sets --
        Part 1: Latin alphabet No. 1, ISO 8859-1:1987.
        Part 2: Latin alphabet No ISO 8859-2, 1987.
        Part 3: Latin alphabet No. 3, ISO 8859-3, 1988.
        Part 4: Latin alphabet No. 4, ISO 84, 1988.
        Part 5: Latin/Cyrillic alphabet, ISO 8859-5, 1988.
        Part 6: Latin/Arabic alphabet, ISO 8859-6,7.
        Part 7: Latin/Greek alphabet, ISO 8859-7, 1987.
        Part 8: Latin/Hebrew alphabet, ISO 8859-8, 1988.
    Part 9: Latin alphabet No. 5, ISO 8859-9, 1990.

15.  Authors' Addresses

   Tim Berners-Lee
   Director, W3 Conium
   MIT Laboratory for Computer Science
   545 Technology Square
   Cambridge, MA 02139, U.S.A.

   Fax: +1 (6178 8682
   EMail: timbl@w3.org


   Roy T. Fielding
   Department of Information and Computer Science
   UniversityCalifornia
   Irvine, CA 92717-3425, U.S.A.

   Fax: +1 (714) 824-4056
   EMail: fielding@ics.uci.edu


   Henrikstyk Nielsen
   W3 Consortium
   MIT Laboratory for Computer Science
   545 Technology Square
   Cambridge, MA 02139S.A.

   Fax: +1 (617) 258 8682
   EMail: frystyk@w3.org










Berners-Lee, et al           Informatio                    [Page 54]

RFC 1945                        HTTP/1.0                        May 1996


Appendic
   These appendices are provided for informational reasons only -- they
   do not form a part of the HTTP/1.0 specifion.

A.  Internet Media Type message/http

   In addition to defining the HTTP/1.0 protocol, this document serves
  the specification for the Internet media type "message/http". The
   following is to be registered with IANA [13].

   Media Type name:         message

       Media subtype name:      http

       Required parameters:     none

   Optional parameters:     version, msgtype

              version: The HTTP-Version number of the enclosed message
                   (e.g., "1.0"). If not present, the version can be
                       determined from the first lif the body.

              msgtype: The message type -- "request" or "response". If
                       not presenhe type can be determined from the
                       first line of the body.

       Encoding considerations: on7bit", "8bit", or "binary" are
                                permitted

       Security considerations: none

B. erant Applications

   Although this document specifies the requirements for the generation
   of HTTP/1.0 messages, all applications will be correct in their
   implementation. We therefore recommend that operational applications
   blerant of deviations whenever those deviations can be
   interpreted unambiguously.

   Clients should be tolerant insing the Status-Line and servers
   tolerant when parsing the Request-Line. In particular, they should
   accept any at of SP or HT characters between fields, even though
   only a single SP is required.

   The line terminator for HTTader fields is the sequence CRLF.
   However, we recommend that applications, when parsing such headers,
   recognize ngle LF as a line terminator and ignore the leading CR.



Berners-Lee, et al           Informational                 [Page 55]

RFC 1945                        HTTP/1.0                        May 1996


C.  Relationship to MIME
 HTTP/1.0 uses many of the constructs defined for Internet Mail (RFC
   822 [7]) and the Multipurpose Internet Mail Extons (MIME [5]) to
   allow entities to be transmitted in an open variety of
   representations and with extensible mecsms. However, RFC 1521
   discusses mail, and HTTP has a few features that are different than
   those described in RF21. These differences were carefully chosen
   to optimize performance over binary connections, to allow greater
   frm in the use of new media types, to make date comparisons
   easier, and to acknowledge the practice of some early HTTPvers
   and clients.

   At the time of this writing, it is expected that RFC 1521 will be
   revised. The revisions include some of the practices found in
   HTTP/1.0 but not in RFC 1521.

   This appendix describes specific areas w HTTP differs from RFC
   1521. Proxies and gateways to strict MIME environments should be
   aware of these differencnd provide the appropriate conversions
   where necessary. Proxies and gateways from MIME environments to HTTP
   alsod to be aware of the differences because some conversions may
   be required.

C.1  Conversion to Canonical Form

 C 1521 requires that an Internet mail entity be converted to
   canonical form prior to being transferred, as describedAppendix G
   of RFC 1521 [5]. Section 3.6.1 of this document describes the forms
   allowed for subtypes of the "textdia type when transmitted over
   HTTP.

   RFC 1521 requires that content with a Content-Type of "text"
   represenne breaks as CRLF and forbids the use of CR or LF outside
   of line break sequences. HTTP allows CRLF, bare CR, and baF to
   indicate a line break within text content when a message is
   transmitted over HTTP.

   Where it is possiba proxy or gateway from HTTP to a strict RFC
   1521 environment should translate all line breaks within the text
   m types described in Section 3.6.1 of this document to the RFC
   1521 canonical form of CRLF. Note, however, that this be
   complicated by the presence of a Content-Encoding and by the fact
   that HTTP allows the use of some character  which do not use
   octets 13 and 10 to represent CR and LF, as is the case for some
   multi-byte character sets.



Berners-Lee, et al           Informational                     [Page 56]

RFC 1945                        HTTP/1                      May 1996


C.2  Conversion of Date Formats

   HTTP/1.0 uses a restricted set of date formatsction 3.3) to
   simplify the process of date comparison. Proxies and gateways from
   other protocols should ensure tany Date header field present in a
   message conforms to one of the HTTP/1.0 formats and rewrite the date
   if neces.

C.3  Introduction of Content-Encoding

   RFC 1521 does not include any concept equivalent to HTTP/1.0's
   ContEncoding header field. Since this acts as a modifier on the
   media type, proxies and gateways from HTTP to MIME-compl
   protocols must either change the value of the Content-Type header
   field or decode the Entity-Body before forwar the message. (Some
   experimental applications of Content-Type for Internet mail have used
   a media-type parameter";conversions=<content-coding>" to perform
   an equivalent function as Content-Encoding. However, this parameter
   it part of RFC 1521.)

C.4  No Content-Transfer-Encoding

   HTTP does not use the Content-Transfer-Encoding (CTE) fiof RFC
   1521. Proxies and gateways from MIME-compliant protocols to HTTP must
   remove any non-identity CTE ("quoteintable" or "base64") encoding
   prior to delivering the response message to an HTTP client.

   Proxies and gatewayom HTTP to MIME-compliant protocols are
   responsible for ensuring that the message is in the correct format
   and eing for safe transport on that protocol, where "safe
   transport" is defined by the limitations of the protocol being .
   Such a proxy or gateway should label the data with an appropriate
   Content-Transfer-Encoding if doing so will ive the likelihood of
   safe transport over the destination protocol.

C.5  HTTP Header Fields in Multipart Body-Part
   In RFC 1521, most header fields in multipart body-parts are generally
   ignored unless the field name begins with tent-". In HTTP/1.0,
   multipart body-parts may contain any HTTP header fields which are
   significant to the meanin that part.

D.  Additional Features

   This appendix documents protocol elements used by some existing HTTP
   imentations, but not consistently and correctly across most
   HTTP/1.0 applications. Implementors should be aware of the   features, but cannot rely upon their presence in, or interoperability



Berners-Lee, et al           Information                   [Page 57]

RFC 1945                        HTTP/1.0                        May 1996


   with, r HTTP/1.0 applications.

D.1  Additional Request Methods

D.1.1 PUT

   The PUT method requests that the enclosedity be stored under the
   supplied Request-URI. If the Request-URI refers to an already
   existing resource, the encd entity should be considered as a
   modified version of the one residing on the origin server. If the
   Request-URIs not point to an existing resource, and that URI is
   capable of being defined as a new resource by the requesting us   agent, the origin server can create the resource with that URI.

   The fundamental difference between the POST and requests is
   reflected in the different meaning of the Request-URI. The URI in a
   POST request identifies the rese that will handle the enclosed
   entity as data to be processed. That resource may be a data-accepting
   process, aeway to some other protocol, or a separate entity that
   accepts annotations. In contrast, the URI in a PUT request idfies
   the entity enclosed with the request -- the user agent knows what URI
   is intended and the server should notly the request to some other
   resource.

D.1.2 DELETE

   The DELETE method requests that the origin server delete resource
   identified by the Request-URI.

D.1.3 LINK

   The LINK method establishes one or more Link relations between
   the existing resource identified by the Request-URI and other
   existing resources.

D.1.4 UNLINK

   UNLINK method removes one or more Link relationships from the
   existing resource identified by the Request-URI.

DAdditional Header Field Definitions

D.2.1 Accept

   The Accept request-header field can be used to indicate a list
   media ranges which are acceptable as a response to the request. The
   asterisk "*" character is used to group medipes into ranges, with
   "*/*" indicating all media types and "type/*" indicating all subtypes



Berners-Lee, et a        Informational                     [Page 58]

RFC 1945                        HTTP/1.0                        1996


   of that type. The set of ranges given by the client should represent
   what types are acceptable given thntext of the request.

D.2.2 Accept-Charset

   The Accept-Charset request-header field can be used to indicate a
 st of preferred character sets other than the default US-ASCII and
   ISO-8859-1. This field allows clients capable of rstanding more
   comprehensive or special-purpose character sets to signal that
   capability to a server which is cae of representing documents in
   those character sets.

D.2.3 Accept-Encoding

   The Accept-Encoding request-headield is similar to Accept, but
   restricts the content-coding values which are acceptable in the
   response.

D.2.cept-Language

   The Accept-Language request-header field is similar to Accept, but
   restricts the set of natural uages that are preferred as a
   response to the request.

D.2.5 Content-Language

   The Content-Language entity-hr field describes the natural
   language(s) of the intended audience for the enclosed entity. Note
   that this may ne equivalent to all the languages used within the
   entity.

D.2.6 Link

   The Link entity-header field provides ans for describing a
   relationship between the entity and some other resource. An entity
   may include multiple Linlues. Links at the metainformation level
   typically indicate relationships like hierarchical structure and
   naviga paths.

D.2.7 MIME-Version

   HTTP messages may include a single MIME-Version general-header field
   to indicatet version of the MIME protocol was used to construct
   the message. Use of the MIME-Version header field, as defined bC
   1521 [5], should indicate that the message is MIME-conformant.
   Unfortunately, some older HTTP/1.0 servers sendindiscriminately,
   and thus this field should be ignored.




Berners-Lee, et al           Informational                 [Page 59]

RFC 1945                        HTTP/1.0                        May 1996


D.2.8 Retry-After
 The Retry-After response-header field can be used with a 503 (service
   unavailable) response to indicate how long thrvice is expected to
   be unavailable to the requesting client. The value of this field can
   be either an HTTP-datean integer number of seconds (in decimal)
   after the time of the response.

D.2.9 Title

   The Title entity-headield indicates the title of the entity.

D.2.10 URI

   The URI entity-header field may contain some or all of the Urm
   Resource Identifiers (Section 3.2) by which the Request-URI resource
   can be identified. There is no guaranteet the resource can be
   accessed using the URI(s) specified.































Berners-Lee, et al           Informational                     [Page 60]
                                        T<<                                                                                                                     